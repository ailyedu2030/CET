# è‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿå›¢é˜Ÿåä½œä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºã€Šè‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿå…¨é¢æŠ€æœ¯æ¶æ„å®¡æŸ¥æŠ¥å‘Šã€‹å’Œã€Šè‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿæ·±åº¦ç¬¦åˆæ€§å®¡æŸ¥æŠ¥å‘Šã€‹çš„å‘ç°ï¼Œé’ˆå¯¹å½“å‰å›¢é˜Ÿåä½œä¸­å­˜åœ¨çš„æ²Ÿé€šæ•ˆç‡ã€çŸ¥è¯†ç®¡ç†ã€æµç¨‹è§„èŒƒç­‰é—®é¢˜ï¼Œæå‡ºå…¨é¢çš„å›¢é˜Ÿåä½œä¼˜åŒ–æ–¹æ¡ˆã€‚æ—¨åœ¨å»ºç«‹é«˜æ•ˆã€é€æ˜ã€åä½œçš„å›¢é˜Ÿå·¥ä½œæ¨¡å¼ï¼Œæå‡é¡¹ç›®äº¤ä»˜è´¨é‡å’Œå›¢é˜Ÿæ»¡æ„åº¦ã€‚

---

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

- **æ²Ÿé€šæ•ˆç‡**: å»ºç«‹é«˜æ•ˆçš„å›¢é˜Ÿæ²Ÿé€šæœºåˆ¶å’Œæ¸ é“
- **çŸ¥è¯†å…±äº«**: æ„å»ºå®Œå–„çš„çŸ¥è¯†ç®¡ç†å’Œä¼ æ‰¿ä½“ç³»
- **æµç¨‹è§„èŒƒ**: æ ‡å‡†åŒ–å¼€å‘ã€æµ‹è¯•ã€éƒ¨ç½²æµç¨‹
- **è´¨é‡ä¿è¯**: å»ºç«‹å¤šå±‚æ¬¡çš„è´¨é‡ä¿è¯æœºåˆ¶
- **å›¢é˜Ÿæˆé•¿**: ä¿ƒè¿›å›¢é˜Ÿæˆå‘˜æŠ€èƒ½å‘å±•å’ŒèŒä¸šæˆé•¿

### é‡åŒ–æŒ‡æ ‡

- æ²Ÿé€šå“åº”æ—¶é—´: 4å°æ—¶ â†’ 1å°æ—¶
- çŸ¥è¯†æ–‡æ¡£è¦†ç›–ç‡: 60% â†’ 90%
- æµç¨‹æ ‡å‡†åŒ–ç‡: 70% â†’ 95%
- ä»£ç å®¡æŸ¥è¦†ç›–ç‡: 80% â†’ 100%
- å›¢é˜Ÿæ»¡æ„åº¦: 3.5/5 â†’ 4.5/5

---

## ğŸ“Š å½“å‰å›¢é˜Ÿåä½œç°çŠ¶

### å›¢é˜Ÿç»“æ„åˆ†æ

```yaml
å›¢é˜Ÿç»„æˆ:
  é¡¹ç›®ç®¡ç†: 1äºº (é¡¹ç›®ç»ç†)
  äº§å“è®¾è®¡: 2äºº (äº§å“ç»ç†ã€UI/UXè®¾è®¡å¸ˆ)
  å‰ç«¯å¼€å‘: 3äºº (React/Next.jså¼€å‘å·¥ç¨‹å¸ˆ)
  åç«¯å¼€å‘: 4äºº (Django/Pythonå¼€å‘å·¥ç¨‹å¸ˆ)
  AIç®—æ³•: 2äºº (æœºå™¨å­¦ä¹ å·¥ç¨‹å¸ˆ)
  æµ‹è¯•è´¨é‡: 2äºº (æµ‹è¯•å·¥ç¨‹å¸ˆã€QAå·¥ç¨‹å¸ˆ)
  è¿ç»´éƒ¨ç½²: 2äºº (DevOpså·¥ç¨‹å¸ˆã€è¿ç»´å·¥ç¨‹å¸ˆ)

æ€»è®¡: 16äºº
```

### åä½œé—®é¢˜åˆ†æ

```yaml
æ²Ÿé€šé—®é¢˜:
  - âŒ è·¨å›¢é˜Ÿæ²Ÿé€šä¸åŠæ—¶
  - âŒ éœ€æ±‚å˜æ›´ä¼ è¾¾æ»å
  - âŒ æŠ€æœ¯å†³ç­–ç¼ºä¹é€æ˜åº¦
  - âŒ ä¼šè®®æ•ˆç‡ä½ä¸‹

çŸ¥è¯†ç®¡ç†:
  - âŒ æ–‡æ¡£åˆ†æ•£ä¸”ä¸å®Œæ•´
  - âŒ æŠ€æœ¯çŸ¥è¯†ä¼ æ‰¿å›°éš¾
  - âŒ æœ€ä½³å®è·µæœªæ²‰æ·€
  - âŒ æ–°äººä¸Šæ‰‹å‘¨æœŸé•¿

æµç¨‹è§„èŒƒ:
  - âŒ å¼€å‘æµç¨‹ä¸ç»Ÿä¸€
  - âŒ ä»£ç å®¡æŸ¥æ ‡å‡†ä¸ä¸€è‡´
  - âŒ æµ‹è¯•æµç¨‹ä¸å®Œå–„
  - âŒ å‘å¸ƒæµç¨‹ç¼ºä¹æ ‡å‡†

è´¨é‡ä¿è¯:
  - âŒ è´¨é‡æ ‡å‡†ä¸æ˜ç¡®
  - âŒ ç¼ºé™·è·Ÿè¸ªä¸åŠæ—¶
  - âŒ æ€§èƒ½ç›‘æ§ä¸å®Œå–„
  - âŒ ç”¨æˆ·åé¦ˆå¤„ç†æ»å
```

---

## ğŸ—ï¸ å›¢é˜Ÿåä½œæ¶æ„è®¾è®¡

### ç»„ç»‡æ¶æ„ä¼˜åŒ–

```mermaid
graph TB
    subgraph "é¡¹ç›®ç®¡ç†å±‚"
        PM[é¡¹ç›®ç»ç†]
        PO[äº§å“è´Ÿè´£äºº]
        TL[æŠ€æœ¯è´Ÿè´£äºº]
    end

    subgraph "å¼€å‘å›¢é˜Ÿ"
        FE[å‰ç«¯å›¢é˜Ÿ]
        BE[åç«¯å›¢é˜Ÿ]
        AI[AIç®—æ³•å›¢é˜Ÿ]
    end

    subgraph "è´¨é‡ä¿è¯"
        QA[æµ‹è¯•å›¢é˜Ÿ]
        DevOps[è¿ç»´å›¢é˜Ÿ]
    end

    subgraph "æ”¯æŒå›¢é˜Ÿ"
        UX[è®¾è®¡å›¢é˜Ÿ]
        DOC[æ–‡æ¡£å›¢é˜Ÿ]
    end

    PM --> FE
    PM --> BE
    PM --> AI
    PO --> FE
    PO --> BE
    TL --> FE
    TL --> BE
    TL --> AI

    FE --> QA
    BE --> QA
    AI --> QA
    QA --> DevOps

    UX --> FE
    DOC --> PM
```

### æ²Ÿé€šåä½œæ¨¡å‹

```yaml
æ²Ÿé€šå±‚çº§:
  æˆ˜ç•¥å±‚: é¡¹ç›®æ„¿æ™¯ã€é‡Œç¨‹ç¢‘è§„åˆ’
  æˆ˜æœ¯å±‚: Sprintè§„åˆ’ã€ä»»åŠ¡åˆ†é…
  æ“ä½œå±‚: æ—¥å¸¸å¼€å‘ã€é—®é¢˜è§£å†³

æ²Ÿé€šé¢‘ç‡:
  æ¯æ—¥: ç«™ä¼šã€å³æ—¶æ²Ÿé€š
  æ¯å‘¨: Sprintè¯„å®¡ã€æŠ€æœ¯åˆ†äº«
  æ¯æœˆ: é¡¹ç›®å›é¡¾ã€å›¢é˜Ÿå»ºè®¾
  æ¯å­£åº¦: æˆ˜ç•¥è§„åˆ’ã€ç»©æ•ˆè¯„ä¼°

æ²Ÿé€šå·¥å…·:
  å³æ—¶é€šè®¯: Slack/Teams
  è§†é¢‘ä¼šè®®: Zoom/Teams
  é¡¹ç›®ç®¡ç†: Jira/Azure DevOps
  æ–‡æ¡£åä½œ: Confluence/Notion
  ä»£ç åä½œ: GitHub/GitLab
```

---

## ğŸ”§ æ ¸å¿ƒåä½œæœºåˆ¶

### 1. æ•æ·å¼€å‘æµç¨‹

```python
# scripts/agile_process_manager.py
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum

class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€"""
    BACKLOG = "backlog"
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    CODE_REVIEW = "code_review"
    TESTING = "testing"
    DONE = "done"

class Priority(Enum):
    """ä¼˜å…ˆçº§"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

@dataclass
class Task:
    """ä»»åŠ¡"""
    id: str
    title: str
    description: str
    assignee: str
    reporter: str
    status: TaskStatus
    priority: Priority
    story_points: int
    sprint_id: Optional[str] = None
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()
    due_date: Optional[datetime] = None
    labels: List[str] = None

    def __post_init__(self):
        if self.labels is None:
            self.labels = []

@dataclass
class Sprint:
    """Sprint"""
    id: str
    name: str
    goal: str
    start_date: datetime
    end_date: datetime
    capacity: int  # å›¢é˜Ÿå®¹é‡ï¼ˆæ•…äº‹ç‚¹ï¼‰
    tasks: List[Task] = None

    def __post_init__(self):
        if self.tasks is None:
            self.tasks = []

    @property
    def duration_days(self) -> int:
        return (self.end_date - self.start_date).days

    @property
    def committed_points(self) -> int:
        return sum(task.story_points for task in self.tasks)

    @property
    def completed_points(self) -> int:
        return sum(
            task.story_points for task in self.tasks
            if task.status == TaskStatus.DONE
        )

    @property
    def completion_rate(self) -> float:
        if self.committed_points == 0:
            return 0.0
        return self.completed_points / self.committed_points

class AgileProcessManager:
    """æ•æ·æµç¨‹ç®¡ç†å™¨"""

    def __init__(self):
        self.sprints: List[Sprint] = []
        self.backlog: List[Task] = []
        self.team_velocity: List[int] = []  # å†å²é€Ÿåº¦

    def create_sprint(self, name: str, goal: str, duration_weeks: int = 2) -> Sprint:
        """åˆ›å»ºSprint"""
        start_date = datetime.now()
        end_date = start_date + timedelta(weeks=duration_weeks)

        # åŸºäºå†å²é€Ÿåº¦è®¡ç®—å®¹é‡
        capacity = self._calculate_team_capacity()

        sprint = Sprint(
            id=f"sprint-{len(self.sprints) + 1}",
            name=name,
            goal=goal,
            start_date=start_date,
            end_date=end_date,
            capacity=capacity
        )

        self.sprints.append(sprint)
        return sprint

    def plan_sprint(self, sprint: Sprint) -> bool:
        """Sprintè§„åˆ’"""
        # æŒ‰ä¼˜å…ˆçº§æ’åºå¾…åŠäº‹é¡¹
        sorted_backlog = sorted(
            self.backlog,
            key=lambda t: (t.priority.value, t.created_at)
        )

        committed_points = 0
        selected_tasks = []

        for task in sorted_backlog:
            if committed_points + task.story_points <= sprint.capacity:
                task.sprint_id = sprint.id
                task.status = TaskStatus.TODO
                selected_tasks.append(task)
                committed_points += task.story_points
            else:
                break

        sprint.tasks = selected_tasks

        # ä»å¾…åŠäº‹é¡¹ä¸­ç§»é™¤å·²é€‰æ‹©çš„ä»»åŠ¡
        for task in selected_tasks:
            if task in self.backlog:
                self.backlog.remove(task)

        return True

    def daily_standup(self, sprint: Sprint) -> Dict[str, Any]:
        """æ¯æ—¥ç«™ä¼šæ•°æ®"""
        team_members = set(task.assignee for task in sprint.tasks)

        standup_data = {
            'sprint_info': {
                'name': sprint.name,
                'days_remaining': (sprint.end_date - datetime.now()).days,
                'completion_rate': sprint.completion_rate
            },
            'team_updates': {},
            'blockers': [],
            'burndown': self._calculate_burndown(sprint)
        }

        for member in team_members:
            member_tasks = [t for t in sprint.tasks if t.assignee == member]

            standup_data['team_updates'][member] = {
                'yesterday': [t for t in member_tasks if t.status == TaskStatus.DONE],
                'today': [t for t in member_tasks if t.status == TaskStatus.IN_PROGRESS],
                'blockers': [t for t in member_tasks if 'blocked' in t.labels]
            }

        return standup_data

    def sprint_review(self, sprint: Sprint) -> Dict[str, Any]:
        """Sprintè¯„å®¡"""
        review_data = {
            'sprint_summary': {
                'name': sprint.name,
                'goal': sprint.goal,
                'committed_points': sprint.committed_points,
                'completed_points': sprint.completed_points,
                'completion_rate': sprint.completion_rate
            },
            'completed_tasks': [t for t in sprint.tasks if t.status == TaskStatus.DONE],
            'incomplete_tasks': [t for t in sprint.tasks if t.status != TaskStatus.DONE],
            'velocity': sprint.completed_points,
            'demo_items': [t for t in sprint.tasks if 'demo' in t.labels and t.status == TaskStatus.DONE]
        }

        # æ›´æ–°å›¢é˜Ÿé€Ÿåº¦
        self.team_velocity.append(sprint.completed_points)

        return review_data

    def sprint_retrospective(self, sprint: Sprint,
                           feedback: Dict[str, List[str]]) -> Dict[str, Any]:
        """Sprintå›é¡¾"""
        retrospective_data = {
            'sprint_metrics': {
                'velocity': sprint.completed_points,
                'completion_rate': sprint.completion_rate,
                'average_task_cycle_time': self._calculate_average_cycle_time(sprint)
            },
            'team_feedback': feedback,
            'action_items': self._generate_action_items(feedback),
            'improvement_suggestions': self._analyze_improvement_opportunities(sprint)
        }

        return retrospective_data

    def _calculate_team_capacity(self) -> int:
        """è®¡ç®—å›¢é˜Ÿå®¹é‡"""
        if not self.team_velocity:
            return 40  # é»˜è®¤å®¹é‡

        # ä½¿ç”¨æœ€è¿‘3ä¸ªSprintçš„å¹³å‡é€Ÿåº¦
        recent_velocity = self.team_velocity[-3:]
        return int(sum(recent_velocity) / len(recent_velocity))

    def _calculate_burndown(self, sprint: Sprint) -> List[Dict[str, Any]]:
        """è®¡ç®—ç‡ƒå°½å›¾æ•°æ®"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥åŸºäºä»»åŠ¡å®Œæˆçš„å†å²æ•°æ®
        days_elapsed = (datetime.now() - sprint.start_date).days
        total_days = sprint.duration_days

        ideal_remaining = sprint.committed_points * (total_days - days_elapsed) / total_days
        actual_remaining = sprint.committed_points - sprint.completed_points

        return [
            {
                'day': days_elapsed,
                'ideal_remaining': max(0, ideal_remaining),
                'actual_remaining': actual_remaining
            }
        ]

    def _calculate_average_cycle_time(self, sprint: Sprint) -> float:
        """è®¡ç®—å¹³å‡å‘¨æœŸæ—¶é—´"""
        completed_tasks = [t for t in sprint.tasks if t.status == TaskStatus.DONE]

        if not completed_tasks:
            return 0.0

        total_cycle_time = sum(
            (t.updated_at - t.created_at).days for t in completed_tasks
        )

        return total_cycle_time / len(completed_tasks)

    def _generate_action_items(self, feedback: Dict[str, List[str]]) -> List[str]:
        """ç”Ÿæˆè¡ŒåŠ¨é¡¹"""
        action_items = []

        # åŸºäºåé¦ˆç”Ÿæˆè¡ŒåŠ¨é¡¹
        if 'stop' in feedback:
            for item in feedback['stop']:
                action_items.append(f"åœæ­¢: {item}")

        if 'start' in feedback:
            for item in feedback['start']:
                action_items.append(f"å¼€å§‹: {item}")

        if 'continue' in feedback:
            for item in feedback['continue']:
                action_items.append(f"ç»§ç»­: {item}")

        return action_items

    def _analyze_improvement_opportunities(self, sprint: Sprint) -> List[str]:
        """åˆ†ææ”¹è¿›æœºä¼š"""
        suggestions = []

        if sprint.completion_rate < 0.8:
            suggestions.append("è€ƒè™‘å‡å°‘Sprintæ‰¿è¯ºæˆ–æé«˜ä¼°ç®—å‡†ç¡®æ€§")

        if sprint.completion_rate > 1.0:
            suggestions.append("å›¢é˜Ÿå®¹é‡å¯èƒ½è¢«ä½ä¼°ï¼Œè€ƒè™‘å¢åŠ Sprintæ‰¿è¯º")

        incomplete_tasks = [t for t in sprint.tasks if t.status != TaskStatus.DONE]
        if len(incomplete_tasks) > len(sprint.tasks) * 0.3:
            suggestions.append("å…³æ³¨ä»»åŠ¡åˆ†è§£ç²’åº¦ï¼Œé¿å…ä»»åŠ¡è¿‡å¤§")

        return suggestions

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºæ•æ·æµç¨‹ç®¡ç†å™¨
    agile_manager = AgileProcessManager()

    # åˆ›å»ºSprint
    sprint = agile_manager.create_sprint(
        name="Sprint 1 - ç”¨æˆ·è®¤è¯æ¨¡å—",
        goal="å®Œæˆç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€æƒé™ç®¡ç†åŠŸèƒ½"
    )

    # æ·»åŠ ä»»åŠ¡åˆ°å¾…åŠäº‹é¡¹
    tasks = [
        Task(
            id="task-1",
            title="ç”¨æˆ·æ³¨å†ŒAPIå¼€å‘",
            description="å®ç°ç”¨æˆ·æ³¨å†Œæ¥å£",
            assignee="å¼ ä¸‰",
            reporter="äº§å“ç»ç†",
            status=TaskStatus.BACKLOG,
            priority=Priority.HIGH,
            story_points=5
        ),
        Task(
            id="task-2",
            title="ç™»å½•é¡µé¢å¼€å‘",
            description="å®ç°ç”¨æˆ·ç™»å½•ç•Œé¢",
            assignee="æå››",
            reporter="äº§å“ç»ç†",
            status=TaskStatus.BACKLOG,
            priority=Priority.HIGH,
            story_points=3
        )
    ]

    agile_manager.backlog.extend(tasks)

    # Sprintè§„åˆ’
    agile_manager.plan_sprint(sprint)

    print(f"Sprint '{sprint.name}' è§„åˆ’å®Œæˆ")
    print(f"æ‰¿è¯ºæ•…äº‹ç‚¹: {sprint.committed_points}")
    print(f"é€‰æ‹©ä»»åŠ¡æ•°: {len(sprint.tasks)}")
```

### 2. ä»£ç å®¡æŸ¥æµç¨‹

```python
# scripts/code_review_manager.py
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class ReviewStatus(Enum):
    """å®¡æŸ¥çŠ¶æ€"""
    PENDING = "pending"
    IN_REVIEW = "in_review"
    APPROVED = "approved"
    CHANGES_REQUESTED = "changes_requested"
    REJECTED = "rejected"

class ReviewType(Enum):
    """å®¡æŸ¥ç±»å‹"""
    FEATURE = "feature"
    BUGFIX = "bugfix"
    HOTFIX = "hotfix"
    REFACTOR = "refactor"
    DOCS = "docs"

@dataclass
class ReviewComment:
    """å®¡æŸ¥è¯„è®º"""
    id: str
    reviewer: str
    content: str
    file_path: str
    line_number: int
    severity: str  # info, warning, error
    created_at: datetime = datetime.now()
    resolved: bool = False

@dataclass
class PullRequest:
    """æ‹‰å–è¯·æ±‚"""
    id: str
    title: str
    description: str
    author: str
    branch: str
    target_branch: str
    review_type: ReviewType
    status: ReviewStatus
    reviewers: List[str]
    comments: List[ReviewComment]
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()

    def __post_init__(self):
        if not self.reviewers:
            self.reviewers = []
        if not self.comments:
            self.comments = []

class CodeReviewManager:
    """ä»£ç å®¡æŸ¥ç®¡ç†å™¨"""

    def __init__(self):
        self.pull_requests: List[PullRequest] = []
        self.review_rules = self._load_review_rules()
        self.team_members = self._load_team_members()

    def create_pull_request(self, title: str, description: str,
                          author: str, branch: str,
                          review_type: ReviewType) -> PullRequest:
        """åˆ›å»ºæ‹‰å–è¯·æ±‚"""
        pr_id = f"pr-{len(self.pull_requests) + 1}"

        # è‡ªåŠ¨åˆ†é…å®¡æŸ¥è€…
        reviewers = self._assign_reviewers(author, review_type)

        pr = PullRequest(
            id=pr_id,
            title=title,
            description=description,
            author=author,
            branch=branch,
            target_branch="main",
            review_type=review_type,
            status=ReviewStatus.PENDING,
            reviewers=reviewers
        )

        self.pull_requests.append(pr)

        # å‘é€å®¡æŸ¥é€šçŸ¥
        self._notify_reviewers(pr)

        return pr

    def submit_review(self, pr_id: str, reviewer: str,
                     comments: List[ReviewComment],
                     decision: ReviewStatus) -> bool:
        """æäº¤å®¡æŸ¥"""
        pr = self._find_pr(pr_id)
        if not pr:
            return False

        # æ·»åŠ è¯„è®º
        pr.comments.extend(comments)

        # æ›´æ–°çŠ¶æ€
        if decision == ReviewStatus.APPROVED:
            # æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å®¡æŸ¥è€…éƒ½å·²æ‰¹å‡†
            if self._all_reviewers_approved(pr):
                pr.status = ReviewStatus.APPROVED
                self._notify_approval(pr)
        elif decision == ReviewStatus.CHANGES_REQUESTED:
            pr.status = ReviewStatus.CHANGES_REQUESTED
            self._notify_changes_requested(pr)

        pr.updated_at = datetime.now()
        return True

    def get_review_metrics(self, days: int = 30) -> Dict[str, Any]:
        """è·å–å®¡æŸ¥æŒ‡æ ‡"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_prs = [
            pr for pr in self.pull_requests
            if pr.created_at >= cutoff_date
        ]

        if not recent_prs:
            return {}

        # è®¡ç®—å„ç§æŒ‡æ ‡
        total_prs = len(recent_prs)
        approved_prs = len([pr for pr in recent_prs if pr.status == ReviewStatus.APPROVED])

        # å¹³å‡å®¡æŸ¥æ—¶é—´
        review_times = []
        for pr in recent_prs:
            if pr.status == ReviewStatus.APPROVED:
                review_time = (pr.updated_at - pr.created_at).total_seconds() / 3600
                review_times.append(review_time)

        avg_review_time = sum(review_times) / len(review_times) if review_times else 0

        # å®¡æŸ¥è€…å‚ä¸åº¦
        reviewer_stats = {}
        for pr in recent_prs:
            for reviewer in pr.reviewers:
                if reviewer not in reviewer_stats:
                    reviewer_stats[reviewer] = {'assigned': 0, 'completed': 0}
                reviewer_stats[reviewer]['assigned'] += 1

                # æ£€æŸ¥æ˜¯å¦å®Œæˆå®¡æŸ¥
                reviewer_comments = [c for c in pr.comments if c.reviewer == reviewer]
                if reviewer_comments:
                    reviewer_stats[reviewer]['completed'] += 1

        return {
            'total_pull_requests': total_prs,
            'approval_rate': approved_prs / total_prs if total_prs > 0 else 0,
            'average_review_time_hours': avg_review_time,
            'reviewer_participation': reviewer_stats,
            'review_quality_score': self._calculate_review_quality_score(recent_prs)
        }

    def generate_review_checklist(self, review_type: ReviewType) -> List[str]:
        """ç”Ÿæˆå®¡æŸ¥æ£€æŸ¥æ¸…å•"""
        base_checklist = [
            "ä»£ç ç¬¦åˆå›¢é˜Ÿç¼–ç è§„èŒƒ",
            "æ²¡æœ‰æ˜æ˜¾çš„å®‰å…¨æ¼æ´",
            "ä»£ç é€»è¾‘æ¸…æ™°æ˜“æ‡‚",
            "é€‚å½“çš„é”™è¯¯å¤„ç†",
            "å¿…è¦çš„å•å…ƒæµ‹è¯•",
            "æ–‡æ¡£å’Œæ³¨é‡Šå®Œæ•´"
        ]

        type_specific = {
            ReviewType.FEATURE: [
                "æ–°åŠŸèƒ½ç¬¦åˆéœ€æ±‚è§„æ ¼",
                "ç”¨æˆ·ç•Œé¢å‹å¥½",
                "æ€§èƒ½å½±å“å¯æ¥å—",
                "å‘åå…¼å®¹æ€§"
            ],
            ReviewType.BUGFIX: [
                "ä¿®å¤äº†æŠ¥å‘Šçš„é—®é¢˜",
                "æ²¡æœ‰å¼•å…¥æ–°çš„é—®é¢˜",
                "åŒ…å«å›å½’æµ‹è¯•"
            ],
            ReviewType.HOTFIX: [
                "ä¿®å¤å…³é”®é—®é¢˜",
                "æœ€å°åŒ–å˜æ›´èŒƒå›´",
                "ç´§æ€¥éƒ¨ç½²å°±ç»ª"
            ],
            ReviewType.REFACTOR: [
                "ä¿æŒåŠŸèƒ½ä¸å˜",
                "æé«˜ä»£ç è´¨é‡",
                "æ€§èƒ½ä¼˜åŒ–æ•ˆæœ"
            ]
        }

        return base_checklist + type_specific.get(review_type, [])

    def _assign_reviewers(self, author: str, review_type: ReviewType) -> List[str]:
        """åˆ†é…å®¡æŸ¥è€…"""
        # æ’é™¤ä½œè€…æœ¬äºº
        available_reviewers = [m for m in self.team_members if m != author]

        # æ ¹æ®å®¡æŸ¥ç±»å‹å’Œè§„åˆ™é€‰æ‹©å®¡æŸ¥è€…
        if review_type == ReviewType.HOTFIX:
            # çƒ­ä¿®å¤éœ€è¦é«˜çº§å¼€å‘è€…å®¡æŸ¥
            senior_reviewers = [m for m in available_reviewers if self._is_senior(m)]
            return senior_reviewers[:1] if senior_reviewers else available_reviewers[:1]
        else:
            # å¸¸è§„å®¡æŸ¥éœ€è¦2ä¸ªå®¡æŸ¥è€…
            return available_reviewers[:2]

    def _find_pr(self, pr_id: str) -> Optional[PullRequest]:
        """æŸ¥æ‰¾æ‹‰å–è¯·æ±‚"""
        for pr in self.pull_requests:
            if pr.id == pr_id:
                return pr
        return None

    def _all_reviewers_approved(self, pr: PullRequest) -> bool:
        """æ£€æŸ¥æ‰€æœ‰å®¡æŸ¥è€…æ˜¯å¦éƒ½å·²æ‰¹å‡†"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æ£€æŸ¥æ¯ä¸ªå®¡æŸ¥è€…çš„å…·ä½“å®¡æŸ¥çŠ¶æ€
        approved_reviewers = set()
        for comment in pr.comments:
            if "LGTM" in comment.content or "approved" in comment.content.lower():
                approved_reviewers.add(comment.reviewer)

        return len(approved_reviewers) >= len(pr.reviewers)

    def _calculate_review_quality_score(self, prs: List[PullRequest]) -> float:
        """è®¡ç®—å®¡æŸ¥è´¨é‡è¯„åˆ†"""
        if not prs:
            return 0.0

        total_score = 0
        for pr in prs:
            # åŸºäºè¯„è®ºæ•°é‡å’Œè´¨é‡è®¡ç®—åˆ†æ•°
            comment_score = min(len(pr.comments) * 10, 100)

            # åŸºäºå®¡æŸ¥æ—¶é—´è®¡ç®—åˆ†æ•°
            review_time_hours = (pr.updated_at - pr.created_at).total_seconds() / 3600
            time_score = 100 if review_time_hours <= 24 else max(50, 100 - review_time_hours)

            pr_score = (comment_score + time_score) / 2
            total_score += pr_score

        return total_score / len(prs)

    def _load_review_rules(self) -> Dict[str, Any]:
        """åŠ è½½å®¡æŸ¥è§„åˆ™"""
        return {
            'min_reviewers': 2,
            'require_senior_for_hotfix': True,
            'max_review_time_hours': 48,
            'required_checks': ['tests', 'linting', 'security']
        }

    def _load_team_members(self) -> List[str]:
        """åŠ è½½å›¢é˜Ÿæˆå‘˜"""
        return [
            "å¼ ä¸‰", "æå››", "ç‹äº”", "èµµå…­", "é’±ä¸ƒ", "å­™å…«"
        ]

    def _is_senior(self, member: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºé«˜çº§å¼€å‘è€…"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥åŸºäºæˆå‘˜æŠ€èƒ½ç­‰çº§
        senior_members = ["å¼ ä¸‰", "æå››"]
        return member in senior_members

    def _notify_reviewers(self, pr: PullRequest):
        """é€šçŸ¥å®¡æŸ¥è€…"""
        # å®é™…å®ç°åº”è¯¥å‘é€é‚®ä»¶æˆ–å³æ—¶æ¶ˆæ¯
        print(f"é€šçŸ¥å®¡æŸ¥è€… {pr.reviewers} å®¡æŸ¥PR: {pr.title}")

    def _notify_approval(self, pr: PullRequest):
        """é€šçŸ¥æ‰¹å‡†"""
        print(f"PR {pr.title} å·²è·å¾—æ‰¹å‡†ï¼Œå¯ä»¥åˆå¹¶")

    def _notify_changes_requested(self, pr: PullRequest):
        """é€šçŸ¥éœ€è¦ä¿®æ”¹"""
        print(f"PR {pr.title} éœ€è¦ä¿®æ”¹ï¼Œè¯·æŸ¥çœ‹å®¡æŸ¥æ„è§")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    review_manager = CodeReviewManager()

    # åˆ›å»ºæ‹‰å–è¯·æ±‚
    pr = review_manager.create_pull_request(
        title="æ·»åŠ ç”¨æˆ·è®¤è¯åŠŸèƒ½",
        description="å®ç°JWTè®¤è¯å’Œæƒé™æ§åˆ¶",
        author="å¼ ä¸‰",
        branch="feature/user-auth",
        review_type=ReviewType.FEATURE
    )

    # æäº¤å®¡æŸ¥
    comments = [
        ReviewComment(
            id="comment-1",
            reviewer="æå››",
            content="ä»£ç é€»è¾‘æ¸…æ™°ï¼ŒLGTM",
            file_path="auth.py",
            line_number=50,
            severity="info"
        )
    ]

    review_manager.submit_review(
        pr.id, "æå››", comments, ReviewStatus.APPROVED
    )

    # è·å–å®¡æŸ¥æŒ‡æ ‡
    metrics = review_manager.get_review_metrics()
    print(f"å®¡æŸ¥æŒ‡æ ‡: {metrics}")
```

### 3. çŸ¥è¯†ç®¡ç†ç³»ç»Ÿ

```python
# scripts/knowledge_management.py
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
import json

class DocumentType(Enum):
    """æ–‡æ¡£ç±»å‹"""
    TECHNICAL_SPEC = "technical_spec"
    API_DOCS = "api_docs"
    USER_GUIDE = "user_guide"
    TROUBLESHOOTING = "troubleshooting"
    BEST_PRACTICES = "best_practices"
    MEETING_NOTES = "meeting_notes"
    DECISION_RECORD = "decision_record"

class DocumentStatus(Enum):
    """æ–‡æ¡£çŠ¶æ€"""
    DRAFT = "draft"
    REVIEW = "review"
    PUBLISHED = "published"
    ARCHIVED = "archived"

@dataclass
class Document:
    """æ–‡æ¡£"""
    id: str
    title: str
    content: str
    author: str
    doc_type: DocumentType
    status: DocumentStatus
    tags: List[str]
    version: str = "1.0"
    created_at: datetime = datetime.now()
    updated_at: datetime = datetime.now()
    reviewers: List[str] = None

    def __post_init__(self):
        if self.reviewers is None:
            self.reviewers = []

@dataclass
class KnowledgeItem:
    """çŸ¥è¯†æ¡ç›®"""
    id: str
    title: str
    description: str
    category: str
    difficulty_level: str  # beginner, intermediate, advanced
    related_documents: List[str]
    code_examples: List[str]
    created_by: str
    created_at: datetime = datetime.now()

    def __post_init__(self):
        if self.related_documents is None:
            self.related_documents = []
        if self.code_examples is None:
            self.code_examples = []

class KnowledgeManagementSystem:
    """çŸ¥è¯†ç®¡ç†ç³»ç»Ÿ"""

    def __init__(self):
        self.documents: List[Document] = []
        self.knowledge_items: List[KnowledgeItem] = []
        self.search_index = {}
        self.access_logs = []

    def create_document(self, title: str, content: str, author: str,
                       doc_type: DocumentType, tags: List[str]) -> Document:
        """åˆ›å»ºæ–‡æ¡£"""
        doc_id = f"doc-{len(self.documents) + 1}"

        document = Document(
            id=doc_id,
            title=title,
            content=content,
            author=author,
            doc_type=doc_type,
            status=DocumentStatus.DRAFT,
            tags=tags
        )

        self.documents.append(document)
        self._update_search_index(document)

        return document

    def publish_document(self, doc_id: str, reviewers: List[str]) -> bool:
        """å‘å¸ƒæ–‡æ¡£"""
        document = self._find_document(doc_id)
        if not document:
            return False

        document.reviewers = reviewers
        document.status = DocumentStatus.REVIEW

        # é€šçŸ¥å®¡æŸ¥è€…
        self._notify_reviewers(document)

        return True

    def approve_document(self, doc_id: str, reviewer: str) -> bool:
        """æ‰¹å‡†æ–‡æ¡£"""
        document = self._find_document(doc_id)
        if not document or reviewer not in document.reviewers:
            return False

        # ç®€åŒ–å®ç°ï¼šå‡è®¾ä¸€ä¸ªå®¡æŸ¥è€…æ‰¹å‡†å³å¯å‘å¸ƒ
        document.status = DocumentStatus.PUBLISHED
        document.updated_at = datetime.now()

        return True

    def search_documents(self, query: str, doc_type: Optional[DocumentType] = None) -> List[Document]:
        """æœç´¢æ–‡æ¡£"""
        results = []
        query_lower = query.lower()

        for document in self.documents:
            if document.status != DocumentStatus.PUBLISHED:
                continue

            if doc_type and document.doc_type != doc_type:
                continue

            # ç®€å•çš„æ–‡æœ¬åŒ¹é…
            if (query_lower in document.title.lower() or
                query_lower in document.content.lower() or
                any(query_lower in tag.lower() for tag in document.tags)):
                results.append(document)

        # è®°å½•æœç´¢æ—¥å¿—
        self._log_access("search", query)

        return results

    def create_knowledge_item(self, title: str, description: str,
                            category: str, difficulty_level: str,
                            created_by: str) -> KnowledgeItem:
        """åˆ›å»ºçŸ¥è¯†æ¡ç›®"""
        item_id = f"knowledge-{len(self.knowledge_items) + 1}"

        knowledge_item = KnowledgeItem(
            id=item_id,
            title=title,
            description=description,
            category=category,
            difficulty_level=difficulty_level,
            created_by=created_by
        )

        self.knowledge_items.append(knowledge_item)

        return knowledge_item

    def get_onboarding_materials(self, role: str) -> List[Document]:
        """è·å–å…¥èŒææ–™"""
        role_specific_tags = {
            'frontend': ['react', 'nextjs', 'typescript', 'ui'],
            'backend': ['django', 'python', 'api', 'database'],
            'ai': ['machine-learning', 'deepseek', 'nlp'],
            'devops': ['kubernetes', 'docker', 'ci-cd'],
            'qa': ['testing', 'automation', 'quality']
        }

        relevant_tags = role_specific_tags.get(role.lower(), [])
        onboarding_docs = []

        for document in self.documents:
            if document.status == DocumentStatus.PUBLISHED:
                if (document.doc_type in [DocumentType.USER_GUIDE, DocumentType.BEST_PRACTICES] or
                    any(tag in document.tags for tag in relevant_tags)):
                    onboarding_docs.append(document)

        return onboarding_docs

    def generate_knowledge_report(self) -> Dict[str, Any]:
        """ç”ŸæˆçŸ¥è¯†ç®¡ç†æŠ¥å‘Š"""
        total_docs = len(self.documents)
        published_docs = len([d for d in self.documents if d.status == DocumentStatus.PUBLISHED])

        # æŒ‰ç±»å‹ç»Ÿè®¡æ–‡æ¡£
        doc_type_stats = {}
        for doc_type in DocumentType:
            count = len([d for d in self.documents if d.doc_type == doc_type])
            doc_type_stats[doc_type.value] = count

        # æŒ‰ä½œè€…ç»Ÿè®¡
        author_stats = {}
        for document in self.documents:
            author = document.author
            if author not in author_stats:
                author_stats[author] = 0
            author_stats[author] += 1

        # æœ€å—æ¬¢è¿çš„æ–‡æ¡£ï¼ˆåŸºäºè®¿é—®æ—¥å¿—ï¼‰
        popular_docs = self._get_popular_documents()

        return {
            'total_documents': total_docs,
            'published_documents': published_docs,
            'publication_rate': published_docs / total_docs if total_docs > 0 else 0,
            'documents_by_type': doc_type_stats,
            'documents_by_author': author_stats,
            'popular_documents': popular_docs,
            'knowledge_items_count': len(self.knowledge_items),
            'coverage_analysis': self._analyze_knowledge_coverage()
        }

    def suggest_documentation_gaps(self) -> List[str]:
        """å»ºè®®æ–‡æ¡£ç¼ºå£"""
        gaps = []

        # æ£€æŸ¥å„ç±»å‹æ–‡æ¡£çš„è¦†ç›–æƒ…å†µ
        required_docs = {
            DocumentType.API_DOCS: "APIæ–‡æ¡£",
            DocumentType.USER_GUIDE: "ç”¨æˆ·æŒ‡å—",
            DocumentType.TROUBLESHOOTING: "æ•…éšœæ’æŸ¥",
            DocumentType.BEST_PRACTICES: "æœ€ä½³å®è·µ"
        }

        for doc_type, description in required_docs.items():
            count = len([d for d in self.documents
                        if d.doc_type == doc_type and d.status == DocumentStatus.PUBLISHED])
            if count == 0:
                gaps.append(f"ç¼ºå°‘{description}æ–‡æ¡£")
            elif count < 3:
                gaps.append(f"{description}æ–‡æ¡£æ•°é‡ä¸è¶³ï¼ˆå½“å‰{count}ä¸ªï¼‰")

        # æ£€æŸ¥æŠ€æœ¯æ ˆè¦†ç›–
        tech_stack = ['django', 'nextjs', 'postgresql', 'redis', 'kubernetes']
        for tech in tech_stack:
            tech_docs = [d for d in self.documents
                        if tech in d.tags and d.status == DocumentStatus.PUBLISHED]
            if not tech_docs:
                gaps.append(f"ç¼ºå°‘{tech}ç›¸å…³æ–‡æ¡£")

        return gaps

    def _find_document(self, doc_id: str) -> Optional[Document]:
        """æŸ¥æ‰¾æ–‡æ¡£"""
        for document in self.documents:
            if document.id == doc_id:
                return document
        return None

    def _update_search_index(self, document: Document):
        """æ›´æ–°æœç´¢ç´¢å¼•"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨ä¸“ä¸šçš„æœç´¢å¼•æ“
        words = document.title.lower().split() + document.content.lower().split()
        for word in words:
            if word not in self.search_index:
                self.search_index[word] = []
            if document.id not in self.search_index[word]:
                self.search_index[word].append(document.id)

    def _notify_reviewers(self, document: Document):
        """é€šçŸ¥å®¡æŸ¥è€…"""
        print(f"é€šçŸ¥å®¡æŸ¥è€… {document.reviewers} å®¡æŸ¥æ–‡æ¡£: {document.title}")

    def _log_access(self, action: str, target: str):
        """è®°å½•è®¿é—®æ—¥å¿—"""
        self.access_logs.append({
            'action': action,
            'target': target,
            'timestamp': datetime.now()
        })

    def _get_popular_documents(self, limit: int = 5) -> List[Dict[str, Any]]:
        """è·å–çƒ­é—¨æ–‡æ¡£"""
        # åŸºäºè®¿é—®æ—¥å¿—ç»Ÿè®¡
        doc_access_count = {}
        for log in self.access_logs:
            if log['action'] == 'view':
                doc_id = log['target']
                doc_access_count[doc_id] = doc_access_count.get(doc_id, 0) + 1

        # æ’åºå¹¶è¿”å›å‰Nä¸ª
        sorted_docs = sorted(doc_access_count.items(), key=lambda x: x[1], reverse=True)

        popular_docs = []
        for doc_id, access_count in sorted_docs[:limit]:
            document = self._find_document(doc_id)
            if document:
                popular_docs.append({
                    'title': document.title,
                    'access_count': access_count,
                    'author': document.author
                })

        return popular_docs

    def _analyze_knowledge_coverage(self) -> Dict[str, Any]:
        """åˆ†æçŸ¥è¯†è¦†ç›–æƒ…å†µ"""
        # æŒ‰æŠ€æœ¯æ ˆåˆ†æè¦†ç›–æƒ…å†µ
        tech_coverage = {}
        tech_stack = ['django', 'nextjs', 'postgresql', 'redis', 'kubernetes', 'ai']

        for tech in tech_stack:
            tech_docs = [d for d in self.documents
                        if tech in d.tags and d.status == DocumentStatus.PUBLISHED]
            tech_coverage[tech] = {
                'document_count': len(tech_docs),
                'coverage_score': min(len(tech_docs) * 20, 100)  # æ¯ä¸ªæ–‡æ¡£20åˆ†ï¼Œæœ€é«˜100åˆ†
            }

        return {
            'technology_coverage': tech_coverage,
            'overall_coverage_score': sum(tc['coverage_score'] for tc in tech_coverage.values()) / len(tech_coverage)
        }

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    km_system = KnowledgeManagementSystem()

    # åˆ›å»ºæŠ€æœ¯æ–‡æ¡£
    api_doc = km_system.create_document(
        title="ç”¨æˆ·è®¤è¯APIæ–‡æ¡£",
        content="è¯¦ç»†çš„APIæ¥å£è¯´æ˜...",
        author="å¼ ä¸‰",
        doc_type=DocumentType.API_DOCS,
        tags=["api", "authentication", "django"]
    )

    # å‘å¸ƒæ–‡æ¡£
    km_system.publish_document(api_doc.id, ["æå››", "ç‹äº”"])
    km_system.approve_document(api_doc.id, "æå››")

    # æœç´¢æ–‡æ¡£
    results = km_system.search_documents("è®¤è¯")
    print(f"æœç´¢ç»“æœ: {len(results)} ä¸ªæ–‡æ¡£")

    # ç”ŸæˆæŠ¥å‘Š
    report = km_system.generate_knowledge_report()
    print(f"çŸ¥è¯†ç®¡ç†æŠ¥å‘Š: {report}")

    # è·å–æ–‡æ¡£ç¼ºå£å»ºè®®
    gaps = km_system.suggest_documentation_gaps()
    print(f"æ–‡æ¡£ç¼ºå£: {gaps}")
```

---

## ğŸ“… å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šåŸºç¡€åä½œæœºåˆ¶å»ºç«‹ (2å‘¨)

**ç›®æ ‡**: å»ºç«‹åŸºæœ¬çš„å›¢é˜Ÿåä½œæµç¨‹å’Œå·¥å…·

| ä»»åŠ¡             | è´Ÿè´£äºº       | å·¥æœŸ | éªŒæ”¶æ ‡å‡†         |
| ---------------- | ------------ | ---- | ---------------- |
| æ•æ·æµç¨‹åŸ¹è®­     | é¡¹ç›®ç»ç†     | 2å¤©  | å›¢é˜Ÿç†è§£æ•æ·æ–¹æ³• |
| å·¥å…·å¹³å°æ­å»º     | DevOpså·¥ç¨‹å¸ˆ | 3å¤©  | åä½œå·¥å…·æ­£å¸¸è¿è¡Œ |
| ä»£ç å®¡æŸ¥è§„èŒƒåˆ¶å®š | æŠ€æœ¯è´Ÿè´£äºº   | 2å¤©  | å®¡æŸ¥æ ‡å‡†æ˜ç¡®     |
| æ²Ÿé€šæ¸ é“å»ºç«‹     | é¡¹ç›®ç»ç†     | 1å¤©  | æ²Ÿé€šæœºåˆ¶è¿è¡Œ     |
| å›¢é˜Ÿè§’è‰²å®šä¹‰     | é¡¹ç›®ç»ç†     | 2å¤©  | èŒè´£åˆ†å·¥æ˜ç¡®     |

### é˜¶æ®µäºŒï¼šçŸ¥è¯†ç®¡ç†ä½“ç³» (2å‘¨)

**ç›®æ ‡**: å»ºç«‹å®Œå–„çš„çŸ¥è¯†ç®¡ç†å’Œæ–‡æ¡£ä½“ç³»

| ä»»åŠ¡         | è´Ÿè´£äºº         | å·¥æœŸ | éªŒæ”¶æ ‡å‡†         |
| ------------ | -------------- | ---- | ---------------- |
| æ–‡æ¡£æ¨¡æ¿åˆ¶å®š | æŠ€æœ¯æ–‡æ¡£å·¥ç¨‹å¸ˆ | 3å¤©  | æ¨¡æ¿æ ‡å‡†åŒ–       |
| çŸ¥è¯†åº“æ­å»º   | DevOpså·¥ç¨‹å¸ˆ   | 4å¤©  | çŸ¥è¯†åº“å¯ç”¨       |
| æ–‡æ¡£è¿ç§»æ•´ç† | å…¨ä½“æˆå‘˜       | 5å¤©  | ç°æœ‰æ–‡æ¡£æ•´ç†å®Œæˆ |
| æœç´¢åŠŸèƒ½å®ç° | å‰ç«¯å·¥ç¨‹å¸ˆ     | 2å¤©  | æœç´¢åŠŸèƒ½æ­£å¸¸     |

### é˜¶æ®µä¸‰ï¼šè´¨é‡ä¿è¯æœºåˆ¶ (2å‘¨)

**ç›®æ ‡**: å®Œå–„ä»£ç è´¨é‡å’Œé¡¹ç›®è´¨é‡ä¿è¯æœºåˆ¶

| ä»»åŠ¡           | è´Ÿè´£äºº       | å·¥æœŸ | éªŒæ”¶æ ‡å‡†       |
| -------------- | ------------ | ---- | -------------- |
| è‡ªåŠ¨åŒ–æµ‹è¯•å®Œå–„ | æµ‹è¯•å·¥ç¨‹å¸ˆ   | 5å¤©  | æµ‹è¯•è¦†ç›–ç‡>90% |
| ä»£ç è´¨é‡é—¨ç¦   | DevOpså·¥ç¨‹å¸ˆ | 3å¤©  | è´¨é‡æ£€æŸ¥è‡ªåŠ¨åŒ– |
| æ€§èƒ½ç›‘æ§é›†æˆ   | è¿ç»´å·¥ç¨‹å¸ˆ   | 4å¤©  | æ€§èƒ½ç›‘æ§å®Œå–„   |
| ç¼ºé™·è·Ÿè¸ªä¼˜åŒ–   | QAå·¥ç¨‹å¸ˆ     | 2å¤©  | ç¼ºé™·ç®¡ç†è§„èŒƒ   |

### é˜¶æ®µå››ï¼šæŒç»­æ”¹è¿›æœºåˆ¶ (1å‘¨)

**ç›®æ ‡**: å»ºç«‹å›¢é˜ŸæŒç»­æ”¹è¿›å’Œå­¦ä¹ æœºåˆ¶

| ä»»åŠ¡         | è´Ÿè´£äºº     | å·¥æœŸ | éªŒæ”¶æ ‡å‡†       |
| ------------ | ---------- | ---- | -------------- |
| æŒ‡æ ‡ç›‘æ§ç³»ç»Ÿ | é¡¹ç›®ç»ç†   | 3å¤©  | æŒ‡æ ‡æ”¶é›†è‡ªåŠ¨åŒ– |
| åé¦ˆæœºåˆ¶å»ºç«‹ | é¡¹ç›®ç»ç†   | 2å¤©  | åé¦ˆæ¸ é“ç•…é€š   |
| åŸ¹è®­è®¡åˆ’åˆ¶å®š | æŠ€æœ¯è´Ÿè´£äºº | 2å¤©  | åŸ¹è®­ä½“ç³»å®Œæ•´   |

---

## âœ… éªŒæ”¶æ ‡å‡†

### åä½œæ•ˆç‡éªŒæ”¶

```yaml
æ²Ÿé€šåä½œ:
  - âœ… å›¢é˜Ÿæ²Ÿé€šå“åº”æ—¶é—´ <1å°æ—¶
  - âœ… ä¼šè®®æ•ˆç‡æå‡ >50%
  - âœ… è·¨å›¢é˜Ÿåä½œé¡ºç•…
  - âœ… å†³ç­–é€æ˜åº¦ >90%

æµç¨‹è§„èŒƒ:
  - âœ… å¼€å‘æµç¨‹æ ‡å‡†åŒ–ç‡ >95%
  - âœ… ä»£ç å®¡æŸ¥è¦†ç›–ç‡ 100%
  - âœ… æµ‹è¯•æµç¨‹è‡ªåŠ¨åŒ–ç‡ >80%
  - âœ… å‘å¸ƒæµç¨‹æ ‡å‡†åŒ–

çŸ¥è¯†ç®¡ç†:
  - âœ… æ–‡æ¡£è¦†ç›–ç‡ >90%
  - âœ… çŸ¥è¯†æœç´¢å‡†ç¡®ç‡ >85%
  - âœ… æ–°äººä¸Šæ‰‹æ—¶é—´ <3å¤©
  - âœ… çŸ¥è¯†æ›´æ–°åŠæ—¶æ€§ >90%
```

### è´¨é‡ä¿è¯éªŒæ”¶

```yaml
ä»£ç è´¨é‡:
  - ä»£ç å®¡æŸ¥è¦†ç›–ç‡: 100%
  - ä»£ç è´¨é‡è¯„åˆ†: >8.0/10
  - æŠ€æœ¯å€ºåŠ¡æ§åˆ¶: <10%
  - ä»£ç é‡å¤ç‡: <5%

é¡¹ç›®è´¨é‡:
  - ç¼ºé™·é€ƒé€¸ç‡: <2%
  - æµ‹è¯•è¦†ç›–ç‡: >90%
  - æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡ç‡: >95%
  - ç”¨æˆ·æ»¡æ„åº¦: >4.5/5

å›¢é˜Ÿæ•ˆèƒ½:
  - å›¢é˜Ÿé€Ÿåº¦ç¨³å®šæ€§: å˜åŒ–<20%
  - ä»»åŠ¡å®Œæˆç‡: >95%
  - å›¢é˜Ÿæ»¡æ„åº¦: >4.5/5
  - çŸ¥è¯†åˆ†äº«é¢‘ç‡: æ¯å‘¨>2æ¬¡
```

---

## ğŸ“Š æˆåŠŸæŒ‡æ ‡

### å›¢é˜Ÿåä½œæŒ‡æ ‡

```typescript
interface TeamCollaborationMetrics {
  // æ²Ÿé€šæ•ˆç‡
  communicationResponseTime: number; // æ²Ÿé€šå“åº”æ—¶é—´ (å°æ—¶)
  meetingEfficiency: number; // ä¼šè®®æ•ˆç‡è¯„åˆ† (1-10)
  decisionMakingSpeed: number; // å†³ç­–åˆ¶å®šé€Ÿåº¦ (å¤©)
  crossTeamCollaboration: number; // è·¨å›¢é˜Ÿåä½œè¯„åˆ† (1-10)

  // çŸ¥è¯†ç®¡ç†
  documentationCoverage: number; // æ–‡æ¡£è¦†ç›–ç‡ (%)
  knowledgeSharingFrequency: number; // çŸ¥è¯†åˆ†äº«é¢‘ç‡ (æ¬¡/å‘¨)
  onboardingTime: number; // æ–°äººä¸Šæ‰‹æ—¶é—´ (å¤©)
  knowledgeSearchAccuracy: number; // çŸ¥è¯†æœç´¢å‡†ç¡®ç‡ (%)

  // æµç¨‹æ•ˆç‡
  processStandardization: number; // æµç¨‹æ ‡å‡†åŒ–ç‡ (%)
  codeReviewCoverage: number; // ä»£ç å®¡æŸ¥è¦†ç›–ç‡ (%)
  automationLevel: number; // è‡ªåŠ¨åŒ–æ°´å¹³ (%)
  qualityGateCompliance: number; // è´¨é‡é—¨ç¦åˆè§„ç‡ (%)

  // å›¢é˜Ÿæ»¡æ„åº¦
  teamSatisfaction: number; // å›¢é˜Ÿæ»¡æ„åº¦ (1-5)
  workLifeBalance: number; // å·¥ä½œç”Ÿæ´»å¹³è¡¡ (1-5)
  careerDevelopment: number; // èŒä¸šå‘å±•æ»¡æ„åº¦ (1-5)
  toolSatisfaction: number; // å·¥å…·æ»¡æ„åº¦ (1-5)
}
```

### ä¸šåŠ¡ä»·å€¼æŒ‡æ ‡

```typescript
interface BusinessValueMetrics {
  // äº¤ä»˜æ•ˆç‡
  featureDeliverySpeed: number; // åŠŸèƒ½äº¤ä»˜é€Ÿåº¦ (ä¸ª/æœˆ)
  timeToMarket: number; // ä¸Šå¸‚æ—¶é—´ (å¤©)
  customerSatisfaction: number; // å®¢æˆ·æ»¡æ„åº¦ (1-5)
  defectRate: number; // ç¼ºé™·ç‡ (%)

  // åˆ›æ–°èƒ½åŠ›
  innovationProjects: number; // åˆ›æ–°é¡¹ç›®æ•°é‡ (ä¸ª/å­£åº¦)
  technicalDebtReduction: number; // æŠ€æœ¯å€ºåŠ¡å‡å°‘ (%)
  processImprovement: number; // æµç¨‹æ”¹è¿›æ•°é‡ (ä¸ª/æœˆ)
  bestPracticesAdoption: number; // æœ€ä½³å®è·µé‡‡ç”¨ç‡ (%)

  // å›¢é˜Ÿæˆé•¿
  skillDevelopment: number; // æŠ€èƒ½å‘å±•æŒ‡æ•°
  knowledgeRetention: number; // çŸ¥è¯†ä¿ç•™ç‡ (%)
  teamStability: number; // å›¢é˜Ÿç¨³å®šæ€§ (%)
  leadershipDevelopment: number; // é¢†å¯¼åŠ›å‘å±•æŒ‡æ•°
}
```

---

## ğŸ”„ æŒç»­æ”¹è¿›

### å®šæœŸè¯„ä¼°æœºåˆ¶

1. **æ¯æ—¥ç«™ä¼š**: åŒæ­¥è¿›åº¦ï¼Œè¯†åˆ«é˜»ç¢
2. **æ¯å‘¨å›é¡¾**: è¯„ä¼°åä½œæ•ˆæœï¼Œè°ƒæ•´æµç¨‹
3. **æ¯æœˆæ€»ç»“**: åˆ†ææŒ‡æ ‡è¶‹åŠ¿ï¼Œåˆ¶å®šæ”¹è¿›è®¡åˆ’
4. **å­£åº¦è¯„ä¼°**: å…¨é¢è¯„ä¼°åä½œæˆæ•ˆï¼Œè§„åˆ’ä¸‹å­£åº¦ç›®æ ‡

### æ”¹è¿›å»ºè®®

1. **å·¥å…·ä¼˜åŒ–**: æŒç»­è¯„ä¼°å’Œä¼˜åŒ–åä½œå·¥å…·
2. **æµç¨‹ç²¾ç®€**: å®šæœŸå®¡æŸ¥å’Œç®€åŒ–å·¥ä½œæµç¨‹
3. **æŠ€èƒ½æå‡**: åˆ¶å®šä¸ªäººå’Œå›¢é˜ŸæŠ€èƒ½å‘å±•è®¡åˆ’
4. **æ–‡åŒ–å»ºè®¾**: è¥é€ å¼€æ”¾ã€åä½œã€å­¦ä¹ çš„å›¢é˜Ÿæ–‡åŒ–
5. **åˆ›æ–°æ¿€åŠ±**: é¼“åŠ±å›¢é˜Ÿæˆå‘˜æå‡ºåˆ›æ–°æƒ³æ³•å’Œæ”¹è¿›å»ºè®®

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ•æ·å¼€å‘å®è·µæŒ‡å—](./agile-development-guide.md)
- [ä»£ç å®¡æŸ¥æ ‡å‡†](./code-review-standards.md)
- [çŸ¥è¯†ç®¡ç†æ‰‹å†Œ](./knowledge-management-handbook.md)
- [å›¢é˜Ÿæ²Ÿé€šè§„èŒƒ](./team-communication-guidelines.md)
- [è´¨é‡ä¿è¯æµç¨‹](./quality-assurance-process.md)
- [æŒç»­æ”¹è¿›æœºåˆ¶](./continuous-improvement-framework.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-22  
**æœ€åæ›´æ–°**: 2025-01-22  
**ç»´æŠ¤äººå‘˜**: é¡¹ç›®ç®¡ç†å›¢é˜Ÿ
