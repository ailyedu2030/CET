# è‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿéƒ¨ç½²è¿ç»´ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºã€Šè‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿå…¨é¢æŠ€æœ¯æ¶æ„å®¡æŸ¥æŠ¥å‘Šã€‹å’Œã€Šè‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿæ·±åº¦ç¬¦åˆæ€§å®¡æŸ¥æŠ¥å‘Šã€‹çš„å‘ç°ï¼Œé’ˆå¯¹å½“å‰éƒ¨ç½²è¿ç»´ä½“ç³»çš„ä¸è¶³ï¼Œæå‡ºå…¨é¢çš„DevOpsä¼˜åŒ–æ–¹æ¡ˆã€‚æ—¨åœ¨å»ºç«‹è‡ªåŠ¨åŒ–ã€æ ‡å‡†åŒ–ã€å¯é çš„éƒ¨ç½²è¿ç»´ä½“ç³»ï¼Œæå‡ç³»ç»Ÿäº¤ä»˜æ•ˆç‡å’Œè¿è¡Œç¨³å®šæ€§ã€‚

---

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

- **è‡ªåŠ¨åŒ–éƒ¨ç½²**: å®ç°ä»ä»£ç æäº¤åˆ°ç”Ÿäº§éƒ¨ç½²çš„å…¨è‡ªåŠ¨åŒ–æµç¨‹
- **ç¯å¢ƒä¸€è‡´æ€§**: ç¡®ä¿å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒçš„ä¸€è‡´æ€§
- **å¿«é€Ÿäº¤ä»˜**: ç¼©çŸ­åŠŸèƒ½ä»å¼€å‘åˆ°ä¸Šçº¿çš„å‘¨æœŸ
- **ç¨³å®šè¿ç»´**: å»ºç«‹å¯é çš„ç›‘æ§ã€å¤‡ä»½ã€æ¢å¤æœºåˆ¶
- **å®‰å…¨åˆè§„**: ç¡®ä¿éƒ¨ç½²è¿‡ç¨‹çš„å®‰å…¨æ€§å’Œåˆè§„æ€§

### é‡åŒ–æŒ‡æ ‡

- éƒ¨ç½²é¢‘ç‡: æ¯å‘¨1æ¬¡ â†’ æ¯æ—¥å¤šæ¬¡
- éƒ¨ç½²æ—¶é—´: 2å°æ—¶ â†’ 15åˆ†é’Ÿ
- éƒ¨ç½²æˆåŠŸç‡: 80% â†’ 99%
- å›æ»šæ—¶é—´: 30åˆ†é’Ÿ â†’ 5åˆ†é’Ÿ
- ç¯å¢ƒæ­å»ºæ—¶é—´: 4å°æ—¶ â†’ 30åˆ†é’Ÿ

---

## ğŸ“Š å½“å‰éƒ¨ç½²è¿ç»´ç°çŠ¶

### ç°æœ‰èƒ½åŠ›è¯„ä¼°

```yaml
ä»£ç ç®¡ç†:
  - ç‰ˆæœ¬æ§åˆ¶: âœ… Git + GitHub
  - åˆ†æ”¯ç­–ç•¥: âš ï¸ ç®€å•åˆ†æ”¯æ¨¡å‹
  - ä»£ç å®¡æŸ¥: âš ï¸ åŸºç¡€PRæµç¨‹
  - æ ‡ç­¾ç®¡ç†: âŒ ç¼ºå¤±

æ„å»ºæµç¨‹:
  - è‡ªåŠ¨æ„å»º: âš ï¸ åŸºç¡€CIé…ç½®
  - æµ‹è¯•é›†æˆ: âš ï¸ éƒ¨åˆ†è‡ªåŠ¨åŒ–
  - ä»£ç è´¨é‡æ£€æŸ¥: âŒ ç¼ºå¤±
  - å®‰å…¨æ‰«æ: âŒ ç¼ºå¤±

éƒ¨ç½²æµç¨‹:
  - è‡ªåŠ¨éƒ¨ç½²: âŒ æ‰‹åŠ¨éƒ¨ç½²
  - ç¯å¢ƒç®¡ç†: âš ï¸ åŸºç¡€å®¹å™¨åŒ–
  - é…ç½®ç®¡ç†: âŒ ç¡¬ç¼–ç é…ç½®
  - è“ç»¿éƒ¨ç½²: âŒ ç¼ºå¤±

è¿ç»´ç›‘æ§:
  - æœåŠ¡ç›‘æ§: âš ï¸ åŸºç¡€ç›‘æ§
  - æ—¥å¿—ç®¡ç†: âš ï¸ åˆ†æ•£å­˜å‚¨
  - å¤‡ä»½ç­–ç•¥: âš ï¸ æ‰‹åŠ¨å¤‡ä»½
  - ç¾éš¾æ¢å¤: âŒ ç¼ºå¤±
```

### ä¸»è¦é—®é¢˜

1. **æ‰‹åŠ¨éƒ¨ç½²é£é™©**: ä¾èµ–äººå·¥æ“ä½œï¼Œå®¹æ˜“å‡ºé”™
2. **ç¯å¢ƒä¸ä¸€è‡´**: å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒå·®å¼‚å¤§
3. **é…ç½®ç®¡ç†æ··ä¹±**: é…ç½®åˆ†æ•£ï¼Œéš¾ä»¥ç®¡ç†
4. **ç¼ºä¹å›æ»šæœºåˆ¶**: éƒ¨ç½²å¤±è´¥åæ¢å¤å›°éš¾
5. **ç›‘æ§ä¸å®Œå–„**: ç¼ºä¹å…¨é¢çš„è¿ç»´ç›‘æ§

---

## ğŸ—ï¸ DevOpsæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```mermaid
graph TB
    subgraph "å¼€å‘é˜¶æ®µ"
        A[å¼€å‘è€…] --> B[Gitä»“åº“]
        B --> C[Featureåˆ†æ”¯]
        C --> D[Pull Request]
    end

    subgraph "CI/CDæµæ°´çº¿"
        D --> E[ä»£ç æ£€æŸ¥]
        E --> F[å•å…ƒæµ‹è¯•]
        F --> G[æ„å»ºé•œåƒ]
        G --> H[å®‰å…¨æ‰«æ]
        H --> I[é›†æˆæµ‹è¯•]
    end

    subgraph "éƒ¨ç½²é˜¶æ®µ"
        I --> J[æµ‹è¯•ç¯å¢ƒéƒ¨ç½²]
        J --> K[è‡ªåŠ¨åŒ–æµ‹è¯•]
        K --> L[é¢„ç”Ÿäº§éƒ¨ç½²]
        L --> M[ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²]
    end

    subgraph "è¿ç»´ç›‘æ§"
        M --> N[æœåŠ¡ç›‘æ§]
        N --> O[æ—¥å¿—æ”¶é›†]
        O --> P[å‘Šè­¦é€šçŸ¥]
        P --> Q[è‡ªåŠ¨æ¢å¤]
    end
```

### æŠ€æœ¯æ ˆé€‰æ‹©

```yaml
å®¹å™¨åŒ–:
  - å®¹å™¨è¿è¡Œæ—¶: Docker
  - å®¹å™¨ç¼–æ’: Kubernetes
  - é•œåƒä»“åº“: Harbor
  - ç½‘ç»œ: Calico

CI/CD:
  - æŒç»­é›†æˆ: GitHub Actions
  - éƒ¨ç½²å·¥å…·: ArgoCD
  - é…ç½®ç®¡ç†: Helm
  - å¯†é’¥ç®¡ç†: Vault

åŸºç¡€è®¾æ–½:
  - äº‘å¹³å°: é˜¿é‡Œäº‘/AWS
  - è´Ÿè½½å‡è¡¡: Nginx Ingress
  - å­˜å‚¨: NFS/äº‘å­˜å‚¨
  - ç½‘ç»œ: VPC

ç›‘æ§è¿ç»´:
  - ç›‘æ§: Prometheus + Grafana
  - æ—¥å¿—: ELK Stack
  - å‘Šè­¦: AlertManager
  - å¤‡ä»½: Velero
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. CI/CDæµæ°´çº¿é…ç½®

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  REGISTRY: harbor.company.com
  IMAGE_NAME: english-training-system

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          pip install -r requirements-dev.txt

      - name: Run linting
        run: |
          flake8 backend/
          black --check backend/
          isort --check-only backend/

      - name: Run security scan
        run: |
          bandit -r backend/
          safety check

      - name: SonarQube Scan
        uses: sonarqube-quality-gate-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # å‰ç«¯æ„å»ºå’Œæµ‹è¯•
  frontend-build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies
        run: |
          cd frontend
          pnpm install

      - name: Run linting
        run: |
          cd frontend
          pnpm lint

      - name: Run type checking
        run: |
          cd frontend
          pnpm type-check

      - name: Run tests
        run: |
          cd frontend
          pnpm test

      - name: Build application
        run: |
          cd frontend
          pnpm build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: frontend-build
          path: frontend/.next

  # åç«¯æµ‹è¯•
  backend-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-test.txt

      - name: Run migrations
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379/0
        run: |
          cd backend
          python manage.py migrate

      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379/0
        run: |
          cd backend
          python -m pytest --cov=. --cov-report=xml

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./backend/coverage.xml

  # æ„å»ºå’Œæ¨é€é•œåƒ
  build-and-push:
    needs: [code-quality, frontend-build, backend-test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download frontend build
        uses: actions/download-artifact@v3
        with:
          name: frontend-build
          path: frontend/.next

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Harbor
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-

      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}-backend
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}-frontend
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to staging
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade --install english-training-staging ./k8s/helm \
            --namespace staging \
            --set image.tag=${{ github.sha }} \
            --set environment=staging \
            --values ./k8s/helm/values-staging.yaml

      - name: Wait for deployment
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout status deployment/english-training-backend -n staging
          kubectl rollout status deployment/english-training-frontend -n staging

      - name: Run smoke tests
        run: |
          # è¿è¡Œå†’çƒŸæµ‹è¯•
          python scripts/smoke_tests.py --env staging

  # éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.0"

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to production
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade --install english-training-prod ./k8s/helm \
            --namespace production \
            --set image.tag=${{ github.sha }} \
            --set environment=production \
            --values ./k8s/helm/values-production.yaml

      - name: Wait for deployment
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout status deployment/english-training-backend -n production
          kubectl rollout status deployment/english-training-frontend -n production

      - name: Run health checks
        run: |
          # è¿è¡Œå¥åº·æ£€æŸ¥
          python scripts/health_checks.py --env production

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: "#deployments"
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### 2. Kuberneteséƒ¨ç½²é…ç½®

```yaml
# k8s/helm/templates/backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "english-training.fullname" . }}-backend
  labels:
    {{- include "english-training.labels" . | nindent 4 }}
    component: backend
spec:
  replicas: {{ .Values.backend.replicaCount }}
  selector:
    matchLabels:
      {{- include "english-training.selectorLabels" . | nindent 6 }}
      component: backend
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
      labels:
        {{- include "english-training.selectorLabels" . | nindent 8 }}
        component: backend
    spec:
      serviceAccountName: {{ include "english-training.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.backend.podSecurityContext | nindent 8 }}
      initContainers:
        - name: migrate
          image: "{{ .Values.backend.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          command: ["python", "manage.py", "migrate"]
          env:
            {{- include "english-training.env" . | nindent 12 }}
          volumeMounts:
            - name: config
              mountPath: /app/config
              readOnly: true
      containers:
        - name: backend
          securityContext:
            {{- toYaml .Values.backend.securityContext | nindent 12 }}
          image: "{{ .Values.backend.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.backend.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 8000
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /health/
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /ready/
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          env:
            {{- include "english-training.env" . | nindent 12 }}
          resources:
            {{- toYaml .Values.backend.resources | nindent 12 }}
          volumeMounts:
            - name: config
              mountPath: /app/config
              readOnly: true
            - name: media
              mountPath: /app/media
      volumes:
        - name: config
          configMap:
            name: {{ include "english-training.fullname" . }}
        - name: media
          persistentVolumeClaim:
            claimName: {{ include "english-training.fullname" . }}-media
      {{- with .Values.backend.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.backend.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.backend.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}

---
# k8s/helm/templates/frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "english-training.fullname" . }}-frontend
  labels:
    {{- include "english-training.labels" . | nindent 4 }}
    component: frontend
spec:
  replicas: {{ .Values.frontend.replicaCount }}
  selector:
    matchLabels:
      {{- include "english-training.selectorLabels" . | nindent 6 }}
      component: frontend
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
      labels:
        {{- include "english-training.selectorLabels" . | nindent 8 }}
        component: frontend
    spec:
      serviceAccountName: {{ include "english-training.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.frontend.podSecurityContext | nindent 8 }}
      containers:
        - name: frontend
          securityContext:
            {{- toYaml .Values.frontend.securityContext | nindent 12 }}
          image: "{{ .Values.frontend.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.frontend.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 3000
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
          env:
            - name: NEXT_PUBLIC_API_URL
              value: {{ .Values.frontend.apiUrl | quote }}
            - name: NODE_ENV
              value: {{ .Values.environment | quote }}
          resources:
            {{- toYaml .Values.frontend.resources | nindent 12 }}
      {{- with .Values.frontend.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.frontend.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.frontend.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}

---
# k8s/helm/templates/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "english-training.fullname" . }}
  labels:
    {{- include "english-training.labels" . | nindent 4 }}
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - {{ .Values.ingress.host }}
      secretName: {{ include "english-training.fullname" . }}-tls
  rules:
    - host: {{ .Values.ingress.host }}
      http:
        paths:
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: {{ include "english-training.fullname" . }}-backend
                port:
                  number: 8000
          - path: /admin
            pathType: Prefix
            backend:
              service:
                name: {{ include "english-training.fullname" . }}-backend
                port:
                  number: 8000
          - path: /
            pathType: Prefix
            backend:
              service:
                name: {{ include "english-training.fullname" . }}-frontend
                port:
                  number: 3000
```

### 3. é…ç½®ç®¡ç†ç³»ç»Ÿ

```python
# scripts/config_manager.py
import os
import yaml
import json
from typing import Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass
from enum import Enum

class Environment(Enum):
    """ç¯å¢ƒç±»å‹"""
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"

@dataclass
class ConfigTemplate:
    """é…ç½®æ¨¡æ¿"""
    name: str
    template_path: str
    output_path: str
    variables: Dict[str, Any]

class ConfigManager:
    """é…ç½®ç®¡ç†å™¨"""

    def __init__(self, config_dir: str = "./config"):
        self.config_dir = Path(config_dir)
        self.templates_dir = self.config_dir / "templates"
        self.environments_dir = self.config_dir / "environments"

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.config_dir.mkdir(exist_ok=True)
        self.templates_dir.mkdir(exist_ok=True)
        self.environments_dir.mkdir(exist_ok=True)

    def load_environment_config(self, env: Environment) -> Dict[str, Any]:
        """åŠ è½½ç¯å¢ƒé…ç½®"""
        config_file = self.environments_dir / f"{env.value}.yaml"

        if not config_file.exists():
            raise FileNotFoundError(f"ç¯å¢ƒé…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_file}")

        with open(config_file, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)

    def generate_config(self, env: Environment, template_name: str) -> str:
        """ç”Ÿæˆé…ç½®æ–‡ä»¶"""
        # åŠ è½½ç¯å¢ƒå˜é‡
        env_config = self.load_environment_config(env)

        # åŠ è½½æ¨¡æ¿
        template_file = self.templates_dir / f"{template_name}.yaml.j2"
        if not template_file.exists():
            raise FileNotFoundError(f"é…ç½®æ¨¡æ¿ä¸å­˜åœ¨: {template_file}")

        with open(template_file, 'r', encoding='utf-8') as f:
            template_content = f.read()

        # æ¸²æŸ“æ¨¡æ¿
        from jinja2 import Template
        template = Template(template_content)

        # åˆå¹¶ç¯å¢ƒå˜é‡å’Œç³»ç»Ÿç¯å¢ƒå˜é‡
        variables = {
            **env_config,
            **dict(os.environ),
            'environment': env.value
        }

        return template.render(**variables)

    def deploy_config(self, env: Environment, template_name: str,
                     output_path: Optional[str] = None) -> str:
        """éƒ¨ç½²é…ç½®æ–‡ä»¶"""
        config_content = self.generate_config(env, template_name)

        if output_path is None:
            output_path = f"{template_name}-{env.value}.yaml"

        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(config_content)

        return str(output_file)

    def validate_config(self, env: Environment) -> bool:
        """éªŒè¯é…ç½®"""
        try:
            config = self.load_environment_config(env)

            # æ£€æŸ¥å¿…éœ€çš„é…ç½®é¡¹
            required_keys = [
                'database.host',
                'database.name',
                'redis.host',
                'secret_key',
                'allowed_hosts'
            ]

            for key in required_keys:
                if not self._get_nested_value(config, key):
                    print(f"ç¼ºå°‘å¿…éœ€çš„é…ç½®é¡¹: {key}")
                    return False

            # éªŒè¯æ•°æ®åº“è¿æ¥
            if not self._validate_database_config(config.get('database', {})):
                return False

            # éªŒè¯Redisè¿æ¥
            if not self._validate_redis_config(config.get('redis', {})):
                return False

            return True

        except Exception as e:
            print(f"é…ç½®éªŒè¯å¤±è´¥: {e}")
            return False

    def _get_nested_value(self, data: Dict[str, Any], key: str) -> Any:
        """è·å–åµŒå¥—å­—å…¸çš„å€¼"""
        keys = key.split('.')
        value = data

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return None

        return value

    def _validate_database_config(self, db_config: Dict[str, Any]) -> bool:
        """éªŒè¯æ•°æ®åº“é…ç½®"""
        try:
            import psycopg2

            conn = psycopg2.connect(
                host=db_config.get('host'),
                port=db_config.get('port', 5432),
                database=db_config.get('name'),
                user=db_config.get('user'),
                password=db_config.get('password')
            )
            conn.close()
            return True

        except Exception as e:
            print(f"æ•°æ®åº“è¿æ¥éªŒè¯å¤±è´¥: {e}")
            return False

    def _validate_redis_config(self, redis_config: Dict[str, Any]) -> bool:
        """éªŒè¯Redisé…ç½®"""
        try:
            import redis

            client = redis.Redis(
                host=redis_config.get('host'),
                port=redis_config.get('port', 6379),
                db=redis_config.get('db', 0),
                password=redis_config.get('password')
            )
            client.ping()
            return True

        except Exception as e:
            print(f"Redisè¿æ¥éªŒè¯å¤±è´¥: {e}")
            return False

    def backup_config(self, env: Environment) -> str:
        """å¤‡ä»½é…ç½®"""
        from datetime import datetime

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_dir = self.config_dir / "backups" / timestamp
        backup_dir.mkdir(parents=True, exist_ok=True)

        # å¤‡ä»½ç¯å¢ƒé…ç½®
        env_config_file = self.environments_dir / f"{env.value}.yaml"
        if env_config_file.exists():
            backup_file = backup_dir / f"{env.value}.yaml"
            backup_file.write_text(env_config_file.read_text())

        return str(backup_dir)

    def rollback_config(self, env: Environment, backup_timestamp: str) -> bool:
        """å›æ»šé…ç½®"""
        try:
            backup_dir = self.config_dir / "backups" / backup_timestamp
            backup_file = backup_dir / f"{env.value}.yaml"

            if not backup_file.exists():
                print(f"å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨: {backup_file}")
                return False

            # æ¢å¤é…ç½®
            env_config_file = self.environments_dir / f"{env.value}.yaml"
            env_config_file.write_text(backup_file.read_text())

            return True

        except Exception as e:
            print(f"é…ç½®å›æ»šå¤±è´¥: {e}")
            return False

class SecretManager:
    """å¯†é’¥ç®¡ç†å™¨"""

    def __init__(self, vault_url: str, vault_token: str):
        self.vault_url = vault_url
        self.vault_token = vault_token
        self.client = self._init_vault_client()

    def _init_vault_client(self):
        """åˆå§‹åŒ–Vaultå®¢æˆ·ç«¯"""
        try:
            import hvac

            client = hvac.Client(
                url=self.vault_url,
                token=self.vault_token
            )

            if not client.is_authenticated():
                raise Exception("Vaultè®¤è¯å¤±è´¥")

            return client

        except ImportError:
            print("è¯·å®‰è£…hvacåº“: pip install hvac")
            return None
        except Exception as e:
            print(f"Vaultå®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥: {e}")
            return None

    def get_secret(self, path: str, key: str) -> Optional[str]:
        """è·å–å¯†é’¥"""
        if not self.client:
            return None

        try:
            response = self.client.secrets.kv.v2.read_secret_version(path=path)
            return response['data']['data'].get(key)

        except Exception as e:
            print(f"è·å–å¯†é’¥å¤±è´¥ ({path}/{key}): {e}")
            return None

    def set_secret(self, path: str, secrets: Dict[str, str]) -> bool:
        """è®¾ç½®å¯†é’¥"""
        if not self.client:
            return False

        try:
            self.client.secrets.kv.v2.create_or_update_secret(
                path=path,
                secret=secrets
            )
            return True

        except Exception as e:
            print(f"è®¾ç½®å¯†é’¥å¤±è´¥ ({path}): {e}")
            return False

    def rotate_secret(self, path: str, key: str, new_value: str) -> bool:
        """è½®æ¢å¯†é’¥"""
        if not self.client:
            return False

        try:
            # è·å–ç°æœ‰å¯†é’¥
            response = self.client.secrets.kv.v2.read_secret_version(path=path)
            current_secrets = response['data']['data']

            # æ›´æ–°å¯†é’¥
            current_secrets[key] = new_value

            # ä¿å­˜æ›´æ–°åçš„å¯†é’¥
            return self.set_secret(path, current_secrets)

        except Exception as e:
            print(f"è½®æ¢å¯†é’¥å¤±è´¥ ({path}/{key}): {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # é…ç½®ç®¡ç†
    config_manager = ConfigManager()

    # éªŒè¯ç”Ÿäº§ç¯å¢ƒé…ç½®
    if config_manager.validate_config(Environment.PRODUCTION):
        print("ç”Ÿäº§ç¯å¢ƒé…ç½®éªŒè¯é€šè¿‡")
    else:
        print("ç”Ÿäº§ç¯å¢ƒé…ç½®éªŒè¯å¤±è´¥")

    # ç”ŸæˆKubernetesé…ç½®
    k8s_config = config_manager.generate_config(
        Environment.PRODUCTION,
        "kubernetes"
    )
    print("Kubernetesé…ç½®å·²ç”Ÿæˆ")

    # å¯†é’¥ç®¡ç†
    secret_manager = SecretManager(
        vault_url="https://vault.company.com",
        vault_token=os.getenv("VAULT_TOKEN")
    )

    # è·å–æ•°æ®åº“å¯†ç 
    db_password = secret_manager.get_secret(
        "english-training/production",
        "database_password"
    )
```

### 4. è‡ªåŠ¨åŒ–è¿ç»´è„šæœ¬

```python
# scripts/deployment_manager.py
import subprocess
import time
import requests
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum
import yaml
import json

class DeploymentStrategy(Enum):
    """éƒ¨ç½²ç­–ç•¥"""
    ROLLING_UPDATE = "rolling_update"
    BLUE_GREEN = "blue_green"
    CANARY = "canary"

class DeploymentStatus(Enum):
    """éƒ¨ç½²çŠ¶æ€"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"

@dataclass
class DeploymentConfig:
    """éƒ¨ç½²é…ç½®"""
    environment: str
    namespace: str
    image_tag: str
    strategy: DeploymentStrategy
    replicas: int
    health_check_url: str
    rollback_on_failure: bool = True
    max_unavailable: str = "25%"
    max_surge: str = "25%"

class DeploymentManager:
    """éƒ¨ç½²ç®¡ç†å™¨"""

    def __init__(self, kubeconfig_path: str):
        self.kubeconfig_path = kubeconfig_path
        self.deployment_history: List[Dict[str, Any]] = []

    def deploy(self, config: DeploymentConfig) -> bool:
        """æ‰§è¡Œéƒ¨ç½²"""
        deployment_id = self._generate_deployment_id()

        deployment_record = {
            'id': deployment_id,
            'config': config,
            'status': DeploymentStatus.PENDING,
            'start_time': time.time(),
            'logs': []
        }

        self.deployment_history.append(deployment_record)

        try:
            self._log(deployment_record, "å¼€å§‹éƒ¨ç½²")
            deployment_record['status'] = DeploymentStatus.IN_PROGRESS

            # é¢„éƒ¨ç½²æ£€æŸ¥
            if not self._pre_deployment_checks(config, deployment_record):
                raise Exception("é¢„éƒ¨ç½²æ£€æŸ¥å¤±è´¥")

            # æ‰§è¡Œéƒ¨ç½²ç­–ç•¥
            if config.strategy == DeploymentStrategy.ROLLING_UPDATE:
                success = self._rolling_update_deployment(config, deployment_record)
            elif config.strategy == DeploymentStrategy.BLUE_GREEN:
                success = self._blue_green_deployment(config, deployment_record)
            elif config.strategy == DeploymentStrategy.CANARY:
                success = self._canary_deployment(config, deployment_record)
            else:
                raise Exception(f"ä¸æ”¯æŒçš„éƒ¨ç½²ç­–ç•¥: {config.strategy}")

            if success:
                # éƒ¨ç½²åæ£€æŸ¥
                if self._post_deployment_checks(config, deployment_record):
                    deployment_record['status'] = DeploymentStatus.SUCCESS
                    self._log(deployment_record, "éƒ¨ç½²æˆåŠŸ")
                    return True
                else:
                    raise Exception("éƒ¨ç½²åæ£€æŸ¥å¤±è´¥")
            else:
                raise Exception("éƒ¨ç½²æ‰§è¡Œå¤±è´¥")

        except Exception as e:
            self._log(deployment_record, f"éƒ¨ç½²å¤±è´¥: {e}")
            deployment_record['status'] = DeploymentStatus.FAILED

            # è‡ªåŠ¨å›æ»š
            if config.rollback_on_failure:
                self._log(deployment_record, "å¼€å§‹è‡ªåŠ¨å›æ»š")
                if self.rollback(config.environment, config.namespace):
                    deployment_record['status'] = DeploymentStatus.ROLLED_BACK
                    self._log(deployment_record, "è‡ªåŠ¨å›æ»šæˆåŠŸ")
                else:
                    self._log(deployment_record, "è‡ªåŠ¨å›æ»šå¤±è´¥")

            return False

        finally:
            deployment_record['end_time'] = time.time()
            deployment_record['duration'] = (
                deployment_record['end_time'] - deployment_record['start_time']
            )

    def _pre_deployment_checks(self, config: DeploymentConfig,
                              deployment_record: Dict[str, Any]) -> bool:
        """é¢„éƒ¨ç½²æ£€æŸ¥"""
        self._log(deployment_record, "æ‰§è¡Œé¢„éƒ¨ç½²æ£€æŸ¥")

        # æ£€æŸ¥é›†ç¾¤è¿æ¥
        if not self._check_cluster_connection():
            self._log(deployment_record, "é›†ç¾¤è¿æ¥æ£€æŸ¥å¤±è´¥")
            return False

        # æ£€æŸ¥å‘½åç©ºé—´
        if not self._check_namespace(config.namespace):
            self._log(deployment_record, f"å‘½åç©ºé—´æ£€æŸ¥å¤±è´¥: {config.namespace}")
            return False

        # æ£€æŸ¥é•œåƒå­˜åœ¨æ€§
        if not self._check_image_exists(config.image_tag):
            self._log(deployment_record, f"é•œåƒæ£€æŸ¥å¤±è´¥: {config.image_tag}")
            return False

        # æ£€æŸ¥èµ„æºé…é¢
        if not self._check_resource_quota(config.namespace, config.replicas):
            self._log(deployment_record, "èµ„æºé…é¢æ£€æŸ¥å¤±è´¥")
            return False

        self._log(deployment_record, "é¢„éƒ¨ç½²æ£€æŸ¥é€šè¿‡")
        return True

    def _rolling_update_deployment(self, config: DeploymentConfig,
                                  deployment_record: Dict[str, Any]) -> bool:
        """æ»šåŠ¨æ›´æ–°éƒ¨ç½²"""
        self._log(deployment_record, "æ‰§è¡Œæ»šåŠ¨æ›´æ–°éƒ¨ç½²")

        try:
            # æ›´æ–°Helméƒ¨ç½²
            cmd = [
                "helm", "upgrade", "--install",
                f"english-training-{config.environment}",
                "./k8s/helm",
                "--namespace", config.namespace,
                "--set", f"image.tag={config.image_tag}",
                "--set", f"replicaCount={config.replicas}",
                "--set", f"strategy.type=RollingUpdate",
                "--set", f"strategy.rollingUpdate.maxUnavailable={config.max_unavailable}",
                "--set", f"strategy.rollingUpdate.maxSurge={config.max_surge}",
                "--values", f"./k8s/helm/values-{config.environment}.yaml",
                "--wait", "--timeout=600s"
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )

            if result.returncode != 0:
                self._log(deployment_record, f"Helméƒ¨ç½²å¤±è´¥: {result.stderr}")
                return False

            self._log(deployment_record, "Helméƒ¨ç½²æˆåŠŸ")

            # ç­‰å¾…éƒ¨ç½²å®Œæˆ
            if not self._wait_for_deployment(config, deployment_record):
                return False

            return True

        except Exception as e:
            self._log(deployment_record, f"æ»šåŠ¨æ›´æ–°éƒ¨ç½²å¤±è´¥: {e}")
            return False

    def _blue_green_deployment(self, config: DeploymentConfig,
                              deployment_record: Dict[str, Any]) -> bool:
        """è“ç»¿éƒ¨ç½²"""
        self._log(deployment_record, "æ‰§è¡Œè“ç»¿éƒ¨ç½²")

        try:
            # è·å–å½“å‰æ´»è·ƒç¯å¢ƒ
            current_env = self._get_active_environment(config.namespace)
            new_env = "blue" if current_env == "green" else "green"

            self._log(deployment_record, f"å½“å‰ç¯å¢ƒ: {current_env}, æ–°ç¯å¢ƒ: {new_env}")

            # éƒ¨ç½²åˆ°æ–°ç¯å¢ƒ
            cmd = [
                "helm", "upgrade", "--install",
                f"english-training-{config.environment}-{new_env}",
                "./k8s/helm",
                "--namespace", config.namespace,
                "--set", f"image.tag={config.image_tag}",
                "--set", f"replicaCount={config.replicas}",
                "--set", f"nameOverride=english-training-{new_env}",
                "--values", f"./k8s/helm/values-{config.environment}.yaml",
                "--wait", "--timeout=600s"
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )

            if result.returncode != 0:
                self._log(deployment_record, f"æ–°ç¯å¢ƒéƒ¨ç½²å¤±è´¥: {result.stderr}")
                return False

            # å¥åº·æ£€æŸ¥
            if not self._health_check_new_environment(config, new_env, deployment_record):
                return False

            # åˆ‡æ¢æµé‡
            if not self._switch_traffic(config.namespace, new_env, deployment_record):
                return False

            # æ¸…ç†æ—§ç¯å¢ƒ
            self._cleanup_old_environment(config.namespace, current_env, deployment_record)

            return True

        except Exception as e:
            self._log(deployment_record, f"è“ç»¿éƒ¨ç½²å¤±è´¥: {e}")
            return False

    def _canary_deployment(self, config: DeploymentConfig,
                          deployment_record: Dict[str, Any]) -> bool:
        """é‡‘ä¸é›€éƒ¨ç½²"""
        self._log(deployment_record, "æ‰§è¡Œé‡‘ä¸é›€éƒ¨ç½²")

        try:
            # éƒ¨ç½²é‡‘ä¸é›€ç‰ˆæœ¬ï¼ˆ10%æµé‡ï¼‰
            canary_replicas = max(1, config.replicas // 10)

            cmd = [
                "helm", "upgrade", "--install",
                f"english-training-{config.environment}-canary",
                "./k8s/helm",
                "--namespace", config.namespace,
                "--set", f"image.tag={config.image_tag}",
                "--set", f"replicaCount={canary_replicas}",
                "--set", "nameOverride=english-training-canary",
                "--set", "service.weight=10",
                "--values", f"./k8s/helm/values-{config.environment}.yaml",
                "--wait", "--timeout=600s"
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )

            if result.returncode != 0:
                self._log(deployment_record, f"é‡‘ä¸é›€éƒ¨ç½²å¤±è´¥: {result.stderr}")
                return False

            # ç›‘æ§é‡‘ä¸é›€ç‰ˆæœ¬
            if not self._monitor_canary(config, deployment_record):
                return False

            # é€æ­¥å¢åŠ æµé‡
            for weight in [25, 50, 75, 100]:
                self._log(deployment_record, f"å¢åŠ é‡‘ä¸é›€æµé‡åˆ° {weight}%")

                if not self._update_canary_weight(config.namespace, weight):
                    self._log(deployment_record, f"æ›´æ–°æµé‡æƒé‡å¤±è´¥: {weight}%")
                    return False

                # ç›‘æ§ä¸€æ®µæ—¶é—´
                time.sleep(300)  # 5åˆ†é’Ÿ

                if not self._check_canary_health(config, deployment_record):
                    return False

            # å®Œå…¨åˆ‡æ¢åˆ°æ–°ç‰ˆæœ¬
            if not self._promote_canary(config, deployment_record):
                return False

            return True

        except Exception as e:
            self._log(deployment_record, f"é‡‘ä¸é›€éƒ¨ç½²å¤±è´¥: {e}")
            return False

    def _post_deployment_checks(self, config: DeploymentConfig,
                               deployment_record: Dict[str, Any]) -> bool:
        """éƒ¨ç½²åæ£€æŸ¥"""
        self._log(deployment_record, "æ‰§è¡Œéƒ¨ç½²åæ£€æŸ¥")

        # å¥åº·æ£€æŸ¥
        if not self._health_check(config.health_check_url, deployment_record):
            return False

        # åŠŸèƒ½æµ‹è¯•
        if not self._run_smoke_tests(config, deployment_record):
            return False

        # æ€§èƒ½æ£€æŸ¥
        if not self._performance_check(config, deployment_record):
            return False

        self._log(deployment_record, "éƒ¨ç½²åæ£€æŸ¥é€šè¿‡")
        return True

    def _health_check(self, url: str, deployment_record: Dict[str, Any],
                     max_retries: int = 10, delay: int = 30) -> bool:
        """å¥åº·æ£€æŸ¥"""
        self._log(deployment_record, f"å¼€å§‹å¥åº·æ£€æŸ¥: {url}")

        for i in range(max_retries):
            try:
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    self._log(deployment_record, "å¥åº·æ£€æŸ¥é€šè¿‡")
                    return True
                else:
                    self._log(deployment_record,
                             f"å¥åº·æ£€æŸ¥å¤±è´¥ (å°è¯• {i+1}/{max_retries}): HTTP {response.status_code}")
            except Exception as e:
                self._log(deployment_record,
                         f"å¥åº·æ£€æŸ¥å¼‚å¸¸ (å°è¯• {i+1}/{max_retries}): {e}")

            if i < max_retries - 1:
                time.sleep(delay)

        self._log(deployment_record, "å¥åº·æ£€æŸ¥æœ€ç»ˆå¤±è´¥")
        return False

    def rollback(self, environment: str, namespace: str) -> bool:
        """å›æ»šéƒ¨ç½²"""
        try:
            # è·å–ä¸Šä¸€ä¸ªç‰ˆæœ¬
            cmd = [
                "helm", "history",
                f"english-training-{environment}",
                "--namespace", namespace,
                "--max", "2",
                "--output", "json"
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )

            if result.returncode != 0:
                print(f"è·å–éƒ¨ç½²å†å²å¤±è´¥: {result.stderr}")
                return False

            history = json.loads(result.stdout)
            if len(history) < 2:
                print("æ²¡æœ‰å¯å›æ»šçš„ç‰ˆæœ¬")
                return False

            previous_revision = history[-2]['revision']

            # æ‰§è¡Œå›æ»š
            cmd = [
                "helm", "rollback",
                f"english-training-{environment}",
                str(previous_revision),
                "--namespace", namespace,
                "--wait", "--timeout=600s"
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )

            if result.returncode != 0:
                print(f"å›æ»šå¤±è´¥: {result.stderr}")
                return False

            print(f"å›æ»šåˆ°ç‰ˆæœ¬ {previous_revision} æˆåŠŸ")
            return True

        except Exception as e:
            print(f"å›æ»šå¼‚å¸¸: {e}")
            return False

    def _log(self, deployment_record: Dict[str, Any], message: str):
        """è®°å½•æ—¥å¿—"""
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
        log_entry = f"[{timestamp}] {message}"
        deployment_record['logs'].append(log_entry)
        print(log_entry)

    def _generate_deployment_id(self) -> str:
        """ç”Ÿæˆéƒ¨ç½²ID"""
        import uuid
        return str(uuid.uuid4())[:8]

    def _check_cluster_connection(self) -> bool:
        """æ£€æŸ¥é›†ç¾¤è¿æ¥"""
        try:
            cmd = ["kubectl", "cluster-info"]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )
            return result.returncode == 0
        except Exception:
            return False

    def _check_namespace(self, namespace: str) -> bool:
        """æ£€æŸ¥å‘½åç©ºé—´"""
        try:
            cmd = ["kubectl", "get", "namespace", namespace]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )
            return result.returncode == 0
        except Exception:
            return False

    def _check_image_exists(self, image_tag: str) -> bool:
        """æ£€æŸ¥é•œåƒå­˜åœ¨æ€§"""
        # è¿™é‡Œå¯ä»¥é›†æˆHarbor APIæ¥æ£€æŸ¥é•œåƒ
        # ç®€åŒ–å®ç°ï¼Œå‡è®¾é•œåƒå­˜åœ¨
        return True

    def _check_resource_quota(self, namespace: str, replicas: int) -> bool:
        """æ£€æŸ¥èµ„æºé…é¢"""
        # è¿™é‡Œå¯ä»¥æ£€æŸ¥CPUã€å†…å­˜ç­‰èµ„æºé…é¢
        # ç®€åŒ–å®ç°ï¼Œå‡è®¾èµ„æºå……è¶³
        return True

    def _wait_for_deployment(self, config: DeploymentConfig,
                           deployment_record: Dict[str, Any]) -> bool:
        """ç­‰å¾…éƒ¨ç½²å®Œæˆ"""
        self._log(deployment_record, "ç­‰å¾…éƒ¨ç½²å®Œæˆ")

        try:
            cmd = [
                "kubectl", "rollout", "status",
                f"deployment/english-training-{config.environment}-backend",
                "--namespace", config.namespace,
                "--timeout=600s"
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env={**subprocess.os.environ, "KUBECONFIG": self.kubeconfig_path}
            )

            return result.returncode == 0

        except Exception as e:
            self._log(deployment_record, f"ç­‰å¾…éƒ¨ç½²å®Œæˆå¤±è´¥: {e}")
            return False

    def _run_smoke_tests(self, config: DeploymentConfig,
                        deployment_record: Dict[str, Any]) -> bool:
        """è¿è¡Œå†’çƒŸæµ‹è¯•"""
        self._log(deployment_record, "è¿è¡Œå†’çƒŸæµ‹è¯•")

        try:
            # è¿è¡Œå†’çƒŸæµ‹è¯•è„šæœ¬
            cmd = ["python", "scripts/smoke_tests.py", "--env", config.environment]
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                self._log(deployment_record, "å†’çƒŸæµ‹è¯•é€šè¿‡")
                return True
            else:
                self._log(deployment_record, f"å†’çƒŸæµ‹è¯•å¤±è´¥: {result.stderr}")
                return False

        except Exception as e:
            self._log(deployment_record, f"å†’çƒŸæµ‹è¯•å¼‚å¸¸: {e}")
            return False

    def _performance_check(self, config: DeploymentConfig,
                          deployment_record: Dict[str, Any]) -> bool:
        """æ€§èƒ½æ£€æŸ¥"""
        self._log(deployment_record, "æ‰§è¡Œæ€§èƒ½æ£€æŸ¥")

        # è¿™é‡Œå¯ä»¥é›†æˆæ€§èƒ½æµ‹è¯•å·¥å…·
        # ç®€åŒ–å®ç°ï¼Œå‡è®¾æ€§èƒ½æ­£å¸¸
        time.sleep(5)
        self._log(deployment_record, "æ€§èƒ½æ£€æŸ¥é€šè¿‡")
        return True

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    deployment_manager = DeploymentManager("/path/to/kubeconfig")

    config = DeploymentConfig(
        environment="production",
        namespace="production",
        image_tag="v1.2.3",
        strategy=DeploymentStrategy.ROLLING_UPDATE,
        replicas=3,
        health_check_url="https://api.english-training.com/health"
    )

    success = deployment_manager.deploy(config)
    if success:
        print("éƒ¨ç½²æˆåŠŸ")
    else:
        print("éƒ¨ç½²å¤±è´¥")
```

---

## ğŸ“… å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šåŸºç¡€è®¾æ–½å‡†å¤‡ (2å‘¨)

**ç›®æ ‡**: æ­å»ºåŸºç¡€çš„å®¹å™¨åŒ–å’ŒCI/CDç¯å¢ƒ

| ä»»åŠ¡               | è´Ÿè´£äºº       | å·¥æœŸ | éªŒæ”¶æ ‡å‡†     |
| ------------------ | ------------ | ---- | ------------ |
| Kubernetesé›†ç¾¤æ­å»º | DevOpså·¥ç¨‹å¸ˆ | 3å¤©  | é›†ç¾¤æ­£å¸¸è¿è¡Œ |
| Harboré•œåƒä»“åº“éƒ¨ç½² | DevOpså·¥ç¨‹å¸ˆ | 2å¤©  | é•œåƒæ¨æ‹‰æ­£å¸¸ |
| GitHub Actionsé…ç½® | DevOpså·¥ç¨‹å¸ˆ | 3å¤©  | CIæµæ°´çº¿è¿è¡Œ |
| Helm Chartå¼€å‘     | DevOpså·¥ç¨‹å¸ˆ | 4å¤©  | åº”ç”¨å¯éƒ¨ç½²   |
| åŸºç¡€ç›‘æ§æ­å»º       | è¿ç»´å·¥ç¨‹å¸ˆ   | 2å¤©  | ç›‘æ§æ•°æ®æ­£å¸¸ |

### é˜¶æ®µäºŒï¼šè‡ªåŠ¨åŒ–éƒ¨ç½² (2å‘¨)

**ç›®æ ‡**: å®ç°è‡ªåŠ¨åŒ–éƒ¨ç½²æµç¨‹

| ä»»åŠ¡         | è´Ÿè´£äºº       | å·¥æœŸ | éªŒæ”¶æ ‡å‡†       |
| ------------ | ------------ | ---- | -------------- |
| CDæµæ°´çº¿å¼€å‘ | DevOpså·¥ç¨‹å¸ˆ | 4å¤©  | è‡ªåŠ¨éƒ¨ç½²æˆåŠŸ   |
| é…ç½®ç®¡ç†ç³»ç»Ÿ | DevOpså·¥ç¨‹å¸ˆ | 3å¤©  | é…ç½®è‡ªåŠ¨åŒ–     |
| å¯†é’¥ç®¡ç†é›†æˆ | å®‰å…¨å·¥ç¨‹å¸ˆ   | 3å¤©  | å¯†é’¥å®‰å…¨ç®¡ç†   |
| éƒ¨ç½²è„šæœ¬å¼€å‘ | DevOpså·¥ç¨‹å¸ˆ | 4å¤©  | éƒ¨ç½²è‡ªåŠ¨åŒ–å®Œæˆ |

### é˜¶æ®µä¸‰ï¼šé«˜çº§éƒ¨ç½²ç­–ç•¥ (2å‘¨)

**ç›®æ ‡**: å®ç°è“ç»¿éƒ¨ç½²å’Œé‡‘ä¸é›€éƒ¨ç½²

| ä»»åŠ¡           | è´Ÿè´£äºº       | å·¥æœŸ | éªŒæ”¶æ ‡å‡†     |
| -------------- | ------------ | ---- | ------------ |
| è“ç»¿éƒ¨ç½²å®ç°   | DevOpså·¥ç¨‹å¸ˆ | 4å¤©  | è“ç»¿åˆ‡æ¢æ­£å¸¸ |
| é‡‘ä¸é›€éƒ¨ç½²å®ç° | DevOpså·¥ç¨‹å¸ˆ | 4å¤©  | æµé‡æ§åˆ¶æ­£å¸¸ |
| è‡ªåŠ¨å›æ»šæœºåˆ¶   | DevOpså·¥ç¨‹å¸ˆ | 3å¤©  | å›æ»šåŠŸèƒ½æ­£å¸¸ |
| éƒ¨ç½²ç›‘æ§å®Œå–„   | è¿ç»´å·¥ç¨‹å¸ˆ   | 3å¤©  | ç›‘æ§å‘Šè­¦æ­£å¸¸ |

### é˜¶æ®µå››ï¼šè¿ç»´ä¼˜åŒ– (2å‘¨)

**ç›®æ ‡**: å®Œå–„è¿ç»´ç›‘æ§å’Œè‡ªåŠ¨åŒ–

| ä»»åŠ¡         | è´Ÿè´£äºº         | å·¥æœŸ | éªŒæ”¶æ ‡å‡†     |
| ------------ | -------------- | ---- | ------------ |
| æ—¥å¿—èšåˆç³»ç»Ÿ | è¿ç»´å·¥ç¨‹å¸ˆ     | 4å¤©  | æ—¥å¿—é›†ä¸­ç®¡ç† |
| å¤‡ä»½æ¢å¤ç³»ç»Ÿ | è¿ç»´å·¥ç¨‹å¸ˆ     | 4å¤©  | å¤‡ä»½æ¢å¤æ­£å¸¸ |
| å‘Šè­¦ç³»ç»Ÿä¼˜åŒ– | è¿ç»´å·¥ç¨‹å¸ˆ     | 3å¤©  | å‘Šè­¦åŠæ—¶å‡†ç¡® |
| è¿ç»´æ–‡æ¡£å®Œå–„ | æŠ€æœ¯æ–‡æ¡£å·¥ç¨‹å¸ˆ | 3å¤©  | æ–‡æ¡£å®Œæ•´å¯ç”¨ |

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶

```yaml
è‡ªåŠ¨åŒ–éƒ¨ç½²:
  - âœ… ä»£ç æäº¤åè‡ªåŠ¨è§¦å‘CI/CDæµæ°´çº¿
  - âœ… è‡ªåŠ¨åŒ–æµ‹è¯•é€šè¿‡ç‡ >95%
  - âœ… è‡ªåŠ¨åŒ–éƒ¨ç½²æˆåŠŸç‡ >99%
  - âœ… éƒ¨ç½²æ—¶é—´ <15åˆ†é’Ÿ

ç¯å¢ƒç®¡ç†:
  - âœ… å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒä¸€è‡´æ€§
  - âœ… é…ç½®ç®¡ç†è‡ªåŠ¨åŒ–
  - âœ… å¯†é’¥ç®¡ç†å®‰å…¨æ€§
  - âœ… ç¯å¢ƒå¿«é€Ÿæ­å»º <30åˆ†é’Ÿ

éƒ¨ç½²ç­–ç•¥:
  - âœ… æ»šåŠ¨æ›´æ–°éƒ¨ç½²æ­£å¸¸
  - âœ… è“ç»¿éƒ¨ç½²åˆ‡æ¢æ­£å¸¸
  - âœ… é‡‘ä¸é›€éƒ¨ç½²æµé‡æ§åˆ¶æ­£å¸¸
  - âœ… è‡ªåŠ¨å›æ»šæœºåˆ¶æœ‰æ•ˆ

ç›‘æ§è¿ç»´:
  - âœ… æœåŠ¡ç›‘æ§è¦†ç›–ç‡ >95%
  - âœ… æ—¥å¿—èšåˆå’ŒæŸ¥è¯¢æ­£å¸¸
  - âœ… å‘Šè­¦åŠæ—¶æ€§ <5åˆ†é’Ÿ
  - âœ… å¤‡ä»½æ¢å¤åŠŸèƒ½æ­£å¸¸
```

### æ€§èƒ½éªŒæ”¶

```yaml
éƒ¨ç½²æ€§èƒ½:
  - éƒ¨ç½²é¢‘ç‡: æ¯æ—¥å¤šæ¬¡
  - éƒ¨ç½²æ—¶é—´: <15åˆ†é’Ÿ
  - éƒ¨ç½²æˆåŠŸç‡: >99%
  - å›æ»šæ—¶é—´: <5åˆ†é’Ÿ

ç³»ç»Ÿæ€§èƒ½:
  - æœåŠ¡å¯ç”¨æ€§: >99.9%
  - å“åº”æ—¶é—´: <2ç§’
  - å¹¶å‘å¤„ç†: >1000 req/s
  - èµ„æºåˆ©ç”¨ç‡: 70-80%

è¿ç»´æ•ˆç‡:
  - æ•…éšœæ£€æµ‹æ—¶é—´: <5åˆ†é’Ÿ
  - æ•…éšœæ¢å¤æ—¶é—´: <30åˆ†é’Ÿ
  - è¿ç»´è‡ªåŠ¨åŒ–ç‡: >80%
  - äººå·¥å¹²é¢„æ¬¡æ•°: <5æ¬¡/æœˆ
```

### å®‰å…¨éªŒæ”¶

```yaml
éƒ¨ç½²å®‰å…¨:
  - âœ… é•œåƒå®‰å…¨æ‰«æé€šè¿‡
  - âœ… å¯†é’¥ç®¡ç†å®‰å…¨
  - âœ… ç½‘ç»œéš”ç¦»æ­£å¸¸
  - âœ… è®¿é—®æ§åˆ¶æœ‰æ•ˆ

è¿ç»´å®‰å…¨:
  - âœ… å®¡è®¡æ—¥å¿—å®Œæ•´
  - âœ… æƒé™æ§åˆ¶ä¸¥æ ¼
  - âœ… æ•°æ®å¤‡ä»½åŠ å¯†
  - âœ… åˆè§„æ€§æ£€æŸ¥é€šè¿‡
```

---

## ğŸ“Š æˆåŠŸæŒ‡æ ‡

### è¿ç»´æ•ˆç‡æŒ‡æ ‡

```typescript
interface DevOpsMetrics {
  // éƒ¨ç½²æŒ‡æ ‡
  deploymentFrequency: number; // éƒ¨ç½²é¢‘ç‡ (æ¬¡/å¤©)
  deploymentLeadTime: number; // éƒ¨ç½²å‰ç½®æ—¶é—´ (å°æ—¶)
  deploymentSuccessRate: number; // éƒ¨ç½²æˆåŠŸç‡ (%)
  rollbackFrequency: number; // å›æ»šé¢‘ç‡ (æ¬¡/æœˆ)

  // è´¨é‡æŒ‡æ ‡
  changeFailureRate: number; // å˜æ›´å¤±è´¥ç‡ (%)
  meanTimeToRecovery: number; // å¹³å‡æ¢å¤æ—¶é—´ (åˆ†é’Ÿ)
  systemAvailability: number; // ç³»ç»Ÿå¯ç”¨æ€§ (%)
  defectEscapeRate: number; // ç¼ºé™·é€ƒé€¸ç‡ (%)

  // æ•ˆç‡æŒ‡æ ‡
  automationCoverage: number; // è‡ªåŠ¨åŒ–è¦†ç›–ç‡ (%)
  manualInterventions: number; // äººå·¥å¹²é¢„æ¬¡æ•° (æ¬¡/æœˆ)
  incidentResolutionTime: number; // äº‹ä»¶è§£å†³æ—¶é—´ (å°æ—¶)
  teamProductivity: number; // å›¢é˜Ÿç”Ÿäº§åŠ›æŒ‡æ•°
}
```

### ä¸šåŠ¡å½±å“æŒ‡æ ‡

```typescript
interface BusinessImpactMetrics {
  // äº¤ä»˜æŒ‡æ ‡
  timeToMarket: number; // ä¸Šå¸‚æ—¶é—´ (å¤©)
  featureDeliveryRate: number; // åŠŸèƒ½äº¤ä»˜ç‡ (ä¸ª/æœˆ)
  customerSatisfaction: number; // å®¢æˆ·æ»¡æ„åº¦ (1-5)
  systemPerformance: number; // ç³»ç»Ÿæ€§èƒ½æŒ‡æ•°

  // æˆæœ¬æŒ‡æ ‡
  infrastructureCost: number; // åŸºç¡€è®¾æ–½æˆæœ¬ (å…ƒ/æœˆ)
  operationalCost: number; // è¿ç»´æˆæœ¬ (å…ƒ/æœˆ)
  developmentCost: number; // å¼€å‘æˆæœ¬ (å…ƒ/æœˆ)
  totalCostOfOwnership: number; // æ€»æ‹¥æœ‰æˆæœ¬ (å…ƒ/å¹´)
}
```

---

## ğŸ”„ æŒç»­æ”¹è¿›

### ç›‘æ§å’Œåº¦é‡

```python
# scripts/devops_metrics_collector.py
import time
import json
from typing import Dict, List, Any
from datetime import datetime, timedelta
from dataclasses import dataclass

@dataclass
class DeploymentMetric:
    """éƒ¨ç½²æŒ‡æ ‡"""
    timestamp: datetime
    environment: str
    duration: float
    success: bool
    rollback: bool
    version: str

class DevOpsMetricsCollector:
    """DevOpsæŒ‡æ ‡æ”¶é›†å™¨"""

    def __init__(self):
        self.deployment_history: List[DeploymentMetric] = []
        self.incident_history: List[Dict[str, Any]] = []

    def record_deployment(self, metric: DeploymentMetric):
        """è®°å½•éƒ¨ç½²æŒ‡æ ‡"""
        self.deployment_history.append(metric)

    def calculate_deployment_frequency(self, days: int = 30) -> float:
        """è®¡ç®—éƒ¨ç½²é¢‘ç‡"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_deployments = [
            d for d in self.deployment_history
            if d.timestamp >= cutoff_date
        ]
        return len(recent_deployments) / days

    def calculate_deployment_success_rate(self, days: int = 30) -> float:
        """è®¡ç®—éƒ¨ç½²æˆåŠŸç‡"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_deployments = [
            d for d in self.deployment_history
            if d.timestamp >= cutoff_date
        ]

        if not recent_deployments:
            return 0.0

        successful_deployments = [
            d for d in recent_deployments if d.success
        ]

        return len(successful_deployments) / len(recent_deployments) * 100

    def calculate_mean_deployment_time(self, days: int = 30) -> float:
        """è®¡ç®—å¹³å‡éƒ¨ç½²æ—¶é—´"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_deployments = [
            d for d in self.deployment_history
            if d.timestamp >= cutoff_date and d.success
        ]

        if not recent_deployments:
            return 0.0

        total_duration = sum(d.duration for d in recent_deployments)
        return total_duration / len(recent_deployments)

    def calculate_rollback_rate(self, days: int = 30) -> float:
        """è®¡ç®—å›æ»šç‡"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_deployments = [
            d for d in self.deployment_history
            if d.timestamp >= cutoff_date
        ]

        if not recent_deployments:
            return 0.0

        rollback_deployments = [
            d for d in recent_deployments if d.rollback
        ]

        return len(rollback_deployments) / len(recent_deployments) * 100

    def generate_report(self) -> Dict[str, Any]:
        """ç”ŸæˆæŒ‡æ ‡æŠ¥å‘Š"""
        return {
            'deployment_frequency': self.calculate_deployment_frequency(),
            'deployment_success_rate': self.calculate_deployment_success_rate(),
            'mean_deployment_time': self.calculate_mean_deployment_time(),
            'rollback_rate': self.calculate_rollback_rate(),
            'total_deployments': len(self.deployment_history),
            'report_generated_at': datetime.now().isoformat()
        }
```

### ä¼˜åŒ–å»ºè®®

1. **å®šæœŸè¯„å®¡**: æ¯æœˆè¿›è¡ŒDevOpsæµç¨‹è¯„å®¡
2. **å·¥å…·å‡çº§**: æŒç»­å…³æ³¨æ–°æŠ€æœ¯å’Œå·¥å…·
3. **å›¢é˜ŸåŸ¹è®­**: å®šæœŸè¿›è¡ŒDevOpsæŠ€èƒ½åŸ¹è®­
4. **æµç¨‹ä¼˜åŒ–**: åŸºäºæŒ‡æ ‡æ•°æ®ä¼˜åŒ–æµç¨‹
5. **è‡ªåŠ¨åŒ–æ‰©å±•**: æŒç»­æ‰©å¤§è‡ªåŠ¨åŒ–è¦†ç›–èŒƒå›´

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [Kuberneteséƒ¨ç½²æŒ‡å—](./k8s-deployment-guide.md)
- [CI/CDæµæ°´çº¿é…ç½®](./cicd-pipeline-config.md)
- [ç›‘æ§å‘Šè­¦é…ç½®](./monitoring-alerting-config.md)
- [å®‰å…¨æœ€ä½³å®è·µ](./security-best-practices.md)
- [æ•…éšœæ’æŸ¥æ‰‹å†Œ](./troubleshooting-guide.md)
- [è¿ç»´æ“ä½œæ‰‹å†Œ](./operations-manual.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-22  
**æœ€åæ›´æ–°**: 2025-01-22  
**ç»´æŠ¤äººå‘˜**: DevOpså›¢é˜Ÿ
