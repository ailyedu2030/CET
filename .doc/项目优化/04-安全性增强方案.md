# è‹±è¯­å››çº§æ™ºèƒ½è®­ç»ƒç³»ç»Ÿå®‰å…¨æ€§å¢å¼ºæ–¹æ¡ˆ

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ22æ—¥  
**åŸºäºæŠ¥å‘Š**: å…¨é¢æŠ€æœ¯æ¶æ„å®¡æŸ¥æŠ¥å‘Š + æ·±åº¦ç¬¦åˆæ€§å®¡æŸ¥æŠ¥å‘Š  
**ä¼˜åŒ–ç›®æ ‡**: å»ºç«‹å…¨é¢çš„ç³»ç»Ÿå®‰å…¨é˜²æŠ¤ä½“ç³»  
**é¢„æœŸæ”¶ç›Š**: å®‰å…¨é£é™©é™ä½90%ï¼Œåˆè§„æ€§æå‡100%  
**å®æ–½å‘¨æœŸ**: 8-10å‘¨

---

## ğŸ” å®‰å…¨ç°çŠ¶è¯„ä¼°

### å½“å‰å®‰å…¨åŸºçº¿

åŸºäºå®¡æŸ¥æŠ¥å‘Šï¼Œç³»ç»Ÿå®‰å…¨ç°çŠ¶åˆ†æï¼š

| å®‰å…¨é¢†åŸŸ     | å½“å‰çŠ¶æ€ | é£é™©ç­‰çº§ | ç›®æ ‡çŠ¶æ€   | æ”¹è¿›ä¼˜å…ˆçº§ |
| ------------ | -------- | -------- | ---------- | ---------- |
| **èº«ä»½è®¤è¯** | åŸºç¡€å®ç° | ğŸŸ¡ ä¸­ç­‰  | å¤šå› å­è®¤è¯ | ğŸ”´ é«˜      |
| **æƒé™æ§åˆ¶** | è§’è‰²åŸºç¡€ | ğŸŸ¡ ä¸­ç­‰  | ç»†ç²’åº¦æƒé™ | ğŸ”´ é«˜      |
| **æ•°æ®åŠ å¯†** | éƒ¨åˆ†åŠ å¯† | ğŸ”´ é«˜    | å…¨é¢åŠ å¯†   | ğŸ”´ é«˜      |
| **APIå®‰å…¨**  | åŸºç¡€é˜²æŠ¤ | ğŸŸ¡ ä¸­ç­‰  | å…¨é¢é˜²æŠ¤   | ğŸŸ¡ ä¸­      |
| **è¾“å…¥éªŒè¯** | ä¸å®Œæ•´   | ğŸ”´ é«˜    | å…¨é¢éªŒè¯   | ğŸ”´ é«˜      |
| **æ—¥å¿—å®¡è®¡** | åŸºç¡€æ—¥å¿— | ğŸŸ¡ ä¸­ç­‰  | å®Œæ•´å®¡è®¡   | ğŸŸ¡ ä¸­      |
| **å®‰å…¨ç›‘æ§** | ç¼ºå¤±     | ğŸ”´ é«˜    | å®æ—¶ç›‘æ§   | ğŸ”´ é«˜      |
| **åˆè§„æ€§**   | éƒ¨åˆ†åˆè§„ | ğŸŸ¡ ä¸­ç­‰  | å…¨é¢åˆè§„   | ğŸŸ¡ ä¸­      |

### æ ¸å¿ƒå®‰å…¨é£é™©

1. **ğŸ”´ é«˜é£é™©**
   - æ•æ„Ÿæ•°æ®æœªåŠ å¯†å­˜å‚¨
   - ç¼ºä¹å®Œæ•´çš„è¾“å…¥éªŒè¯æœºåˆ¶
   - å®‰å…¨ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶ç¼ºå¤±
   - APIæ¥å£ç¼ºä¹é€Ÿç‡é™åˆ¶

2. **ğŸŸ¡ ä¸­é£é™©**
   - æƒé™æ§åˆ¶ç²’åº¦ä¸å¤Ÿç»†
   - æ—¥å¿—è®°å½•ä¸å¤Ÿå®Œæ•´
   - ç¬¬ä¸‰æ–¹ä¾èµ–å®‰å…¨æ£€æŸ¥ä¸è¶³
   - å®‰å…¨é…ç½®ç®¡ç†ä¸è§„èŒƒ

3. **ğŸŸ¢ ä½é£é™©**
   - åŸºç¡€è®¤è¯æœºåˆ¶å·²å®ç°
   - HTTPSä¼ è¾“å·²å¯ç”¨
   - åŸºæœ¬çš„SQLæ³¨å…¥é˜²æŠ¤

---

## ğŸ” èº«ä»½è®¤è¯å’Œæˆæƒå¢å¼º

### 1. å¤šå› å­è®¤è¯(MFA)å®æ–½

#### JWTå¢å¼ºè®¤è¯

```python
# users/authentication.py
import jwt
import pyotp
from datetime import datetime, timedelta
from django.contrib.auth import get_user_model
from django.core.cache import cache
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from cryptography.fernet import Fernet

User = get_user_model()

class EnhancedJWTAuthentication(BaseAuthentication):
    """å¢å¼ºçš„JWTè®¤è¯"""

    def authenticate(self, request):
        """è®¤è¯ç”¨æˆ·"""
        auth_header = request.META.get('HTTP_AUTHORIZATION')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None

        token = auth_header.split(' ')[1]

        try:
            # éªŒè¯JWT token
            payload = jwt.decode(
                token,
                settings.SECRET_KEY,
                algorithms=['HS256']
            )

            user_id = payload.get('user_id')
            session_id = payload.get('session_id')

            # æ£€æŸ¥ä¼šè¯æ˜¯å¦æœ‰æ•ˆ
            if not self._is_session_valid(user_id, session_id):
                raise AuthenticationFailed('ä¼šè¯å·²å¤±æ•ˆ')

            # æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
            user = User.objects.get(id=user_id, is_active=True)

            # æ£€æŸ¥æ˜¯å¦éœ€è¦MFAéªŒè¯
            if user.mfa_enabled and not self._is_mfa_verified(user_id, session_id):
                raise AuthenticationFailed('éœ€è¦å¤šå› å­è®¤è¯')

            # æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
            self._update_last_activity(user_id, session_id)

            return (user, token)

        except jwt.ExpiredSignatureError:
            raise AuthenticationFailed('Tokenå·²è¿‡æœŸ')
        except jwt.InvalidTokenError:
            raise AuthenticationFailed('æ— æ•ˆçš„Token')
        except User.DoesNotExist:
            raise AuthenticationFailed('ç”¨æˆ·ä¸å­˜åœ¨')

    def _is_session_valid(self, user_id: int, session_id: str) -> bool:
        """æ£€æŸ¥ä¼šè¯æ˜¯å¦æœ‰æ•ˆ"""
        session_key = f'session:{user_id}:{session_id}'
        return cache.get(session_key) is not None

    def _is_mfa_verified(self, user_id: int, session_id: str) -> bool:
        """æ£€æŸ¥MFAæ˜¯å¦å·²éªŒè¯"""
        mfa_key = f'mfa_verified:{user_id}:{session_id}'
        return cache.get(mfa_key, False)

    def _update_last_activity(self, user_id: int, session_id: str) -> None:
        """æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´"""
        session_key = f'session:{user_id}:{session_id}'
        cache.set(session_key, datetime.now().isoformat(), timeout=3600)

class MFAService:
    """å¤šå› å­è®¤è¯æœåŠ¡"""

    def __init__(self):
        self.cipher = Fernet(settings.MFA_ENCRYPTION_KEY)

    def generate_totp_secret(self, user: User) -> str:
        """ç”ŸæˆTOTPå¯†é’¥"""
        secret = pyotp.random_base32()

        # åŠ å¯†å­˜å‚¨å¯†é’¥
        encrypted_secret = self.cipher.encrypt(secret.encode())
        user.totp_secret = encrypted_secret
        user.save(update_fields=['totp_secret'])

        return secret

    def verify_totp(self, user: User, token: str) -> bool:
        """éªŒè¯TOTPä»¤ç‰Œ"""
        if not user.totp_secret:
            return False

        try:
            # è§£å¯†å¯†é’¥
            secret = self.cipher.decrypt(user.totp_secret).decode()
            totp = pyotp.TOTP(secret)

            # éªŒè¯ä»¤ç‰Œï¼ˆå…è®¸30ç§’æ—¶é—´çª—å£ï¼‰
            return totp.verify(token, valid_window=1)

        except Exception:
            return False

    def generate_backup_codes(self, user: User) -> List[str]:
        """ç”Ÿæˆå¤‡ç”¨éªŒè¯ç """
        import secrets

        codes = []
        for _ in range(10):
            code = '-'.join([
                secrets.token_hex(2).upper()
                for _ in range(3)
            ])
            codes.append(code)

        # åŠ å¯†å­˜å‚¨å¤‡ç”¨ç 
        encrypted_codes = [
            self.cipher.encrypt(code.encode()).decode()
            for code in codes
        ]

        user.backup_codes = encrypted_codes
        user.save(update_fields=['backup_codes'])

        return codes

    def verify_backup_code(self, user: User, code: str) -> bool:
        """éªŒè¯å¤‡ç”¨ç """
        if not user.backup_codes:
            return False

        try:
            # è§£å¯†å¹¶éªŒè¯å¤‡ç”¨ç 
            for i, encrypted_code in enumerate(user.backup_codes):
                decrypted_code = self.cipher.decrypt(encrypted_code.encode()).decode()
                if decrypted_code == code:
                    # ä½¿ç”¨ååˆ é™¤å¤‡ç”¨ç 
                    user.backup_codes.pop(i)
                    user.save(update_fields=['backup_codes'])
                    return True

            return False

        except Exception:
            return False
```

#### ç»†ç²’åº¦æƒé™æ§åˆ¶

```python
# users/permissions.py
from typing import List, Dict, Any
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from rest_framework.permissions import BasePermission
from enum import Enum

class ResourceType(Enum):
    """èµ„æºç±»å‹æšä¸¾"""
    COURSE = 'course'
    LESSON = 'lesson'
    ASSIGNMENT = 'assignment'
    GRADE = 'grade'
    USER = 'user'
    SYSTEM = 'system'

class Action(Enum):
    """æ“ä½œç±»å‹æšä¸¾"""
    CREATE = 'create'
    READ = 'read'
    UPDATE = 'update'
    DELETE = 'delete'
    EXECUTE = 'execute'
    MANAGE = 'manage'

class PermissionManager:
    """æƒé™ç®¡ç†å™¨"""

    def __init__(self):
        self.permission_cache = {}

    def check_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action,
        resource_id: str = None,
        context: Dict[str, Any] = None
    ) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æƒé™"""

        # è¶…çº§ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
        if user.is_superuser:
            return True

        # æ£€æŸ¥è§’è‰²æƒé™
        if self._check_role_permission(user, resource_type, action):
            return True

        # æ£€æŸ¥èµ„æºçº§æƒé™
        if resource_id and self._check_resource_permission(
            user, resource_type, action, resource_id
        ):
            return True

        # æ£€æŸ¥ä¸Šä¸‹æ–‡æƒé™
        if context and self._check_context_permission(
            user, resource_type, action, context
        ):
            return True

        return False

    def _check_role_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action
    ) -> bool:
        """æ£€æŸ¥è§’è‰²æƒé™"""
        role_permissions = {
            'admin': {
                ResourceType.SYSTEM: [Action.MANAGE],
                ResourceType.USER: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
                ResourceType.COURSE: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
            },
            'teacher': {
                ResourceType.COURSE: [Action.CREATE, Action.READ, Action.UPDATE],
                ResourceType.LESSON: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
                ResourceType.ASSIGNMENT: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
                ResourceType.GRADE: [Action.CREATE, Action.READ, Action.UPDATE],
            },
            'student': {
                ResourceType.COURSE: [Action.READ],
                ResourceType.LESSON: [Action.READ],
                ResourceType.ASSIGNMENT: [Action.READ, Action.EXECUTE],
                ResourceType.GRADE: [Action.READ],
            }
        }

        user_role_permissions = role_permissions.get(user.role, {})
        allowed_actions = user_role_permissions.get(resource_type, [])

        return action in allowed_actions

    def _check_resource_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action,
        resource_id: str
    ) -> bool:
        """æ£€æŸ¥èµ„æºçº§æƒé™"""
        # æ•™å¸ˆåªèƒ½æ“ä½œè‡ªå·±çš„è¯¾ç¨‹
        if user.role == 'teacher' and resource_type == ResourceType.COURSE:
            from learning.models import Course
            try:
                course = Course.objects.get(id=resource_id)
                return course.teacher == user
            except Course.DoesNotExist:
                return False

        # å­¦ç”Ÿåªèƒ½è®¿é—®å·²é€‰è¯¾ç¨‹
        if user.role == 'student' and resource_type == ResourceType.COURSE:
            from learning.models import Enrollment
            return Enrollment.objects.filter(
                student=user,
                course_id=resource_id,
                status='active'
            ).exists()

        return False

    def _check_context_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action,
        context: Dict[str, Any]
    ) -> bool:
        """æ£€æŸ¥ä¸Šä¸‹æ–‡æƒé™"""
        # æ—¶é—´çª—å£æƒé™
        if 'time_window' in context:
            from datetime import datetime
            start_time = context['time_window'].get('start')
            end_time = context['time_window'].get('end')
            now = datetime.now()

            if start_time and now < start_time:
                return False
            if end_time and now > end_time:
                return False

        # IPåœ°å€é™åˆ¶
        if 'allowed_ips' in context:
            user_ip = context.get('user_ip')
            allowed_ips = context['allowed_ips']
            if user_ip not in allowed_ips:
                return False

        return True

class ResourcePermission(BasePermission):
    """èµ„æºæƒé™æ£€æŸ¥"""

    def __init__(self, resource_type: ResourceType, action: Action):
        self.resource_type = resource_type
        self.action = action
        self.permission_manager = PermissionManager()

    def has_permission(self, request, view):
        """æ£€æŸ¥æƒé™"""
        if not request.user or not request.user.is_authenticated:
            return False

        # è·å–èµ„æºID
        resource_id = view.kwargs.get('pk') or request.data.get('id')

        # æ„å»ºä¸Šä¸‹æ–‡
        context = {
            'user_ip': self._get_client_ip(request),
            'user_agent': request.META.get('HTTP_USER_AGENT', ''),
            'timestamp': datetime.now()
        }

        return self.permission_manager.check_permission(
            request.user,
            self.resource_type,
            self.action,
            resource_id,
            context
        )

    def _get_client_ip(self, request):
        """è·å–å®¢æˆ·ç«¯IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
```

### 2. ä¼šè¯ç®¡ç†å¢å¼º

```python
# users/session_management.py
import uuid
from datetime import datetime, timedelta
from django.core.cache import cache
from django.contrib.auth import get_user_model
from typing import Dict, List, Optional

User = get_user_model()

class SessionManager:
    """ä¼šè¯ç®¡ç†å™¨"""

    def __init__(self):
        self.session_timeout = 3600  # 1å°æ—¶
        self.max_sessions_per_user = 5

    def create_session(
        self,
        user: User,
        device_info: Dict[str, str],
        ip_address: str
    ) -> str:
        """åˆ›å»ºæ–°ä¼šè¯"""
        session_id = str(uuid.uuid4())

        # æ£€æŸ¥å¹¶æ¸…ç†è¿‡æœŸä¼šè¯
        self._cleanup_expired_sessions(user.id)

        # æ£€æŸ¥ä¼šè¯æ•°é‡é™åˆ¶
        active_sessions = self._get_active_sessions(user.id)
        if len(active_sessions) >= self.max_sessions_per_user:
            # åˆ é™¤æœ€æ—§çš„ä¼šè¯
            oldest_session = min(active_sessions, key=lambda x: x['created_at'])
            self._revoke_session(user.id, oldest_session['session_id'])

        # åˆ›å»ºä¼šè¯æ•°æ®
        session_data = {
            'user_id': user.id,
            'session_id': session_id,
            'device_info': device_info,
            'ip_address': ip_address,
            'created_at': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
            'is_active': True
        }

        # å­˜å‚¨ä¼šè¯
        session_key = f'session:{user.id}:{session_id}'
        cache.set(session_key, session_data, timeout=self.session_timeout)

        # æ›´æ–°ç”¨æˆ·ä¼šè¯åˆ—è¡¨
        self._add_to_user_sessions(user.id, session_id)

        return session_id

    def validate_session(
        self,
        user_id: int,
        session_id: str,
        ip_address: str = None
    ) -> bool:
        """éªŒè¯ä¼šè¯"""
        session_key = f'session:{user_id}:{session_id}'
        session_data = cache.get(session_key)

        if not session_data:
            return False

        # æ£€æŸ¥ä¼šè¯æ˜¯å¦æ¿€æ´»
        if not session_data.get('is_active', False):
            return False

        # æ£€æŸ¥IPåœ°å€ï¼ˆå¯é€‰ï¼‰
        if ip_address and session_data.get('ip_address') != ip_address:
            # è®°å½•å¯ç–‘æ´»åŠ¨
            self._log_suspicious_activity(user_id, session_id, ip_address)
            return False

        # æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
        session_data['last_activity'] = datetime.now().isoformat()
        cache.set(session_key, session_data, timeout=self.session_timeout)

        return True

    def revoke_session(self, user_id: int, session_id: str) -> bool:
        """æ’¤é”€ä¼šè¯"""
        return self._revoke_session(user_id, session_id)

    def revoke_all_sessions(self, user_id: int, except_session: str = None) -> int:
        """æ’¤é”€ç”¨æˆ·æ‰€æœ‰ä¼šè¯"""
        active_sessions = self._get_active_sessions(user_id)
        revoked_count = 0

        for session in active_sessions:
            session_id = session['session_id']
            if session_id != except_session:
                if self._revoke_session(user_id, session_id):
                    revoked_count += 1

        return revoked_count

    def get_user_sessions(self, user_id: int) -> List[Dict]:
        """è·å–ç”¨æˆ·æ´»è·ƒä¼šè¯"""
        return self._get_active_sessions(user_id)

    def _revoke_session(self, user_id: int, session_id: str) -> bool:
        """å†…éƒ¨æ’¤é”€ä¼šè¯æ–¹æ³•"""
        session_key = f'session:{user_id}:{session_id}'
        session_data = cache.get(session_key)

        if session_data:
            session_data['is_active'] = False
            session_data['revoked_at'] = datetime.now().isoformat()
            cache.set(session_key, session_data, timeout=300)  # ä¿ç•™5åˆ†é’Ÿç”¨äºå®¡è®¡

            # ä»ç”¨æˆ·ä¼šè¯åˆ—è¡¨ä¸­ç§»é™¤
            self._remove_from_user_sessions(user_id, session_id)
            return True

        return False

    def _get_active_sessions(self, user_id: int) -> List[Dict]:
        """è·å–ç”¨æˆ·æ´»è·ƒä¼šè¯"""
        user_sessions_key = f'user_sessions:{user_id}'
        session_ids = cache.get(user_sessions_key, [])

        active_sessions = []
        for session_id in session_ids:
            session_key = f'session:{user_id}:{session_id}'
            session_data = cache.get(session_key)

            if session_data and session_data.get('is_active', False):
                active_sessions.append(session_data)

        return active_sessions

    def _add_to_user_sessions(self, user_id: int, session_id: str) -> None:
        """æ·»åŠ åˆ°ç”¨æˆ·ä¼šè¯åˆ—è¡¨"""
        user_sessions_key = f'user_sessions:{user_id}'
        session_ids = cache.get(user_sessions_key, [])

        if session_id not in session_ids:
            session_ids.append(session_id)
            cache.set(user_sessions_key, session_ids, timeout=86400)  # 24å°æ—¶

    def _remove_from_user_sessions(self, user_id: int, session_id: str) -> None:
        """ä»ç”¨æˆ·ä¼šè¯åˆ—è¡¨ä¸­ç§»é™¤"""
        user_sessions_key = f'user_sessions:{user_id}'
        session_ids = cache.get(user_sessions_key, [])

        if session_id in session_ids:
            session_ids.remove(session_id)
            cache.set(user_sessions_key, session_ids, timeout=86400)

    def _cleanup_expired_sessions(self, user_id: int) -> None:
        """æ¸…ç†è¿‡æœŸä¼šè¯"""
        active_sessions = self._get_active_sessions(user_id)
        current_time = datetime.now()

        for session in active_sessions:
            last_activity = datetime.fromisoformat(session['last_activity'])
            if current_time - last_activity > timedelta(seconds=self.session_timeout):
                self._revoke_session(user_id, session['session_id'])

    def _log_suspicious_activity(
        self,
        user_id: int,
        session_id: str,
        suspicious_ip: str
    ) -> None:
        """è®°å½•å¯ç–‘æ´»åŠ¨"""
        from monitoring.models import SecurityEvent

        SecurityEvent.objects.create(
            event_type='suspicious_ip',
            user_id=user_id,
            session_id=session_id,
            details={
                'suspicious_ip': suspicious_ip,
                'timestamp': datetime.now().isoformat()
            },
            severity='medium'
        )
```

---

## ğŸ”’ æ•°æ®ä¿æŠ¤å’ŒåŠ å¯†

### 1. æ•æ„Ÿæ•°æ®åŠ å¯†

```python
# utils/encryption.py
import base64
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from django.conf import settings
from typing import Union, Optional

class DataEncryption:
    """æ•°æ®åŠ å¯†å·¥å…·ç±»"""

    def __init__(self):
        self.master_key = settings.ENCRYPTION_MASTER_KEY.encode()
        self.salt = settings.ENCRYPTION_SALT.encode()

    def _derive_key(self, context: str = 'default') -> bytes:
        """æ´¾ç”ŸåŠ å¯†å¯†é’¥"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self.salt + context.encode(),
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        return key

    def encrypt_field(self, data: str, context: str = 'default') -> str:
        """åŠ å¯†å­—æ®µæ•°æ®"""
        if not data:
            return data

        key = self._derive_key(context)
        fernet = Fernet(key)

        encrypted_data = fernet.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()

    def decrypt_field(self, encrypted_data: str, context: str = 'default') -> str:
        """è§£å¯†å­—æ®µæ•°æ®"""
        if not encrypted_data:
            return encrypted_data

        try:
            key = self._derive_key(context)
            fernet = Fernet(key)

            decoded_data = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = fernet.decrypt(decoded_data)
            return decrypted_data.decode()
        except Exception:
            # è§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ—§æ•°æ®æˆ–æŸåæ•°æ®
            return encrypted_data

    def hash_password(self, password: str, salt: Optional[str] = None) -> tuple:
        """å“ˆå¸Œå¯†ç """
        if salt is None:
            salt = base64.urlsafe_b64encode(hashlib.sha256(
                self.master_key + password.encode()
            ).digest()[:16]).decode()

        # ä½¿ç”¨PBKDF2è¿›è¡Œå¯†ç å“ˆå¸Œ
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt.encode(),
            iterations=100000,
        )

        hashed = base64.urlsafe_b64encode(
            kdf.derive(password.encode())
        ).decode()

        return hashed, salt

    def verify_password(self, password: str, hashed: str, salt: str) -> bool:
        """éªŒè¯å¯†ç """
        try:
            new_hashed, _ = self.hash_password(password, salt)
            return new_hashed == hashed
        except Exception:
            return False

# models/encrypted_fields.py
from django.db import models
from utils.encryption import DataEncryption

class EncryptedTextField(models.TextField):
    """åŠ å¯†æ–‡æœ¬å­—æ®µ"""

    def __init__(self, *args, encryption_context='default', **kwargs):
        self.encryption_context = encryption_context
        self.encryptor = DataEncryption()
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        """ä»æ•°æ®åº“è¯»å–æ—¶è§£å¯†"""
        if value is None:
            return value
        return self.encryptor.decrypt_field(value, self.encryption_context)

    def to_python(self, value):
        """è½¬æ¢ä¸ºPythonå¯¹è±¡"""
        if isinstance(value, str) or value is None:
            return value
        return str(value)

    def get_prep_value(self, value):
        """ä¿å­˜åˆ°æ•°æ®åº“å‰åŠ å¯†"""
        if value is None:
            return value
        return self.encryptor.encrypt_field(str(value), self.encryption_context)

class EncryptedEmailField(models.EmailField):
    """åŠ å¯†é‚®ç®±å­—æ®µ"""

    def __init__(self, *args, **kwargs):
        self.encryptor = DataEncryption()
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        if value is None:
            return value
        return self.encryptor.decrypt_field(value, 'email')

    def get_prep_value(self, value):
        if value is None:
            return value
        return self.encryptor.encrypt_field(str(value), 'email')

class EncryptedJSONField(models.JSONField):
    """åŠ å¯†JSONå­—æ®µ"""

    def __init__(self, *args, encryption_context='json', **kwargs):
        self.encryption_context = encryption_context
        self.encryptor = DataEncryption()
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        if value is None:
            return value

        # å…ˆè§£å¯†ï¼Œå†è§£æJSON
        decrypted = self.encryptor.decrypt_field(value, self.encryption_context)
        return super().to_python(decrypted)

    def get_prep_value(self, value):
        if value is None:
            return value

        # å…ˆåºåˆ—åŒ–JSONï¼Œå†åŠ å¯†
        json_str = super().get_prep_value(value)
        return self.encryptor.encrypt_field(json_str, self.encryption_context)
```

### 2. æ•°æ®åº“å®‰å…¨é…ç½®

```python
# settings/security.py
import os
from pathlib import Path

# æ•°æ®åº“è¿æ¥å®‰å…¨é…ç½®
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST', 'localhost'),
        'PORT': os.getenv('DB_PORT', '5432'),
        'OPTIONS': {
            'sslmode': 'require',  # å¼ºåˆ¶SSLè¿æ¥
            'sslcert': os.getenv('DB_SSL_CERT'),
            'sslkey': os.getenv('DB_SSL_KEY'),
            'sslrootcert': os.getenv('DB_SSL_ROOT_CERT'),
            'connect_timeout': 10,
            'options': '-c default_transaction_isolation=serializable'
        },
        'CONN_MAX_AGE': 600,  # è¿æ¥æ± é…ç½®
        'CONN_HEALTH_CHECKS': True,
    }
}

# Rediså®‰å…¨é…ç½®
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://:{os.getenv('REDIS_PASSWORD')}@{os.getenv('REDIS_HOST', 'localhost')}:6379/1",
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'ssl_cert_reqs': 'required',
                'ssl_ca_certs': os.getenv('REDIS_SSL_CA_CERTS'),
                'ssl_certfile': os.getenv('REDIS_SSL_CERT'),
                'ssl_keyfile': os.getenv('REDIS_SSL_KEY'),
                'health_check_interval': 30,
            },
            'SERIALIZER': 'django_redis.serializers.json.JSONSerializer',
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
        },
        'KEY_PREFIX': 'cet4_training',
        'TIMEOUT': 300,
    }
}

# åŠ å¯†é…ç½®
ENCRYPTION_MASTER_KEY = os.getenv('ENCRYPTION_MASTER_KEY')
ENCRYPTION_SALT = os.getenv('ENCRYPTION_SALT')
MFA_ENCRYPTION_KEY = os.getenv('MFA_ENCRYPTION_KEY')

# å¯†ç ç­–ç•¥
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 12,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
    {
        'NAME': 'users.validators.ComplexPasswordValidator',
    },
]

# ä¼šè¯å®‰å…¨
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'
SESSION_COOKIE_AGE = 3600  # 1å°æ—¶
SESSION_EXPIRE_AT_BROWSER_CLOSE = True
SESSION_SAVE_EVERY_REQUEST = True

# CSRFä¿æŠ¤
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Strict'
CSRF_USE_SESSIONS = True
CSRF_TRUSTED_ORIGINS = [
    'https://cet4-training.example.com',
]

# å®‰å…¨å¤´éƒ¨
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_HSTS_SECONDS = 31536000  # 1å¹´
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_REFERRER_POLICY = 'strict-origin-when-cross-origin'

# æ–‡ä»¶ä¸Šä¼ å®‰å…¨
FILE_UPLOAD_MAX_MEMORY_SIZE = 5242880  # 5MB
DATA_UPLOAD_MAX_MEMORY_SIZE = 5242880  # 5MB
FILE_UPLOAD_PERMISSIONS = 0o644
FILE_UPLOAD_DIRECTORY_PERMISSIONS = 0o755

# å…è®¸çš„æ–‡ä»¶ç±»å‹
ALLOWED_UPLOAD_EXTENSIONS = [
    '.pdf', '.doc', '.docx', '.txt', '.md',
    '.jpg', '.jpeg', '.png', '.gif',
    '.mp3', '.wav', '.mp4', '.avi'
]

# æ—¥å¿—é…ç½®
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'security': {
            'format': '{levelname} {asctime} {name} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'security_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/cet4_training/security.log',
            'maxBytes': 1024*1024*10,  # 10MB
            'backupCount': 10,
            'formatter': 'security',
        },
    },
    'loggers': {
        'security': {
            'handlers': ['security_file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

---

## ğŸ›¡ï¸ APIå®‰å…¨é˜²æŠ¤

### 1. è¾“å…¥éªŒè¯å’Œæ¸…ç†

```python
# utils/validators.py
import re
import html
from typing import Any, Dict, List, Union
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

class InputValidator:
    """è¾“å…¥éªŒè¯å™¨"""

    # å±é™©æ¨¡å¼åˆ—è¡¨
    DANGEROUS_PATTERNS = [
        r'<script[^>]*>.*?</script>',  # XSSè„šæœ¬
        r'javascript:',  # JavaScriptåè®®
        r'vbscript:',  # VBScriptåè®®
        r'on\w+\s*=',  # äº‹ä»¶å¤„ç†å™¨
        r'expression\s*\(',  # CSSè¡¨è¾¾å¼
        r'@import',  # CSSå¯¼å…¥
        r'\bUNION\b.*\bSELECT\b',  # SQLæ³¨å…¥
        r'\bDROP\b.*\bTABLE\b',  # SQLåˆ é™¤
        r'\bINSERT\b.*\bINTO\b',  # SQLæ’å…¥
        r'\bUPDATE\b.*\bSET\b',  # SQLæ›´æ–°
        r'\bDELETE\b.*\bFROM\b',  # SQLåˆ é™¤
        r'\.\./',  # è·¯å¾„éå†
        r'\\\\',  # UNCè·¯å¾„
    ]

    def __init__(self):
        self.compiled_patterns = [
            re.compile(pattern, re.IGNORECASE | re.DOTALL)
            for pattern in self.DANGEROUS_PATTERNS
        ]

    def validate_string(
        self,
        value: str,
        max_length: int = None,
        allow_html: bool = False,
        field_name: str = 'field'
    ) -> str:
        """éªŒè¯å­—ç¬¦ä¸²è¾“å…¥"""
        if not isinstance(value, str):
            raise ValidationError(f'{field_name}å¿…é¡»æ˜¯å­—ç¬¦ä¸²ç±»å‹')

        # é•¿åº¦æ£€æŸ¥
        if max_length and len(value) > max_length:
            raise ValidationError(f'{field_name}é•¿åº¦ä¸èƒ½è¶…è¿‡{max_length}ä¸ªå­—ç¬¦')

        # å±é™©æ¨¡å¼æ£€æŸ¥
        for pattern in self.compiled_patterns:
            if pattern.search(value):
                raise ValidationError(f'{field_name}åŒ…å«ä¸å®‰å…¨çš„å†…å®¹')

        # HTMLæ¸…ç†
        if not allow_html:
            value = html.escape(value)
        else:
            value = self._sanitize_html(value)

        return value.strip()

    def validate_email(self, email: str) -> str:
        """éªŒè¯é‚®ç®±åœ°å€"""
        email_pattern = re.compile(
            r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        )

        if not email_pattern.match(email):
            raise ValidationError('é‚®ç®±åœ°å€æ ¼å¼ä¸æ­£ç¡®')

        return email.lower().strip()

    def validate_phone(self, phone: str) -> str:
        """éªŒè¯æ‰‹æœºå·ç """
        phone_pattern = re.compile(r'^1[3-9]\d{9}$')

        # æ¸…ç†éæ•°å­—å­—ç¬¦
        clean_phone = re.sub(r'\D', '', phone)

        if not phone_pattern.match(clean_phone):
            raise ValidationError('æ‰‹æœºå·ç æ ¼å¼ä¸æ­£ç¡®')

        return clean_phone

    def validate_username(self, username: str) -> str:
        """éªŒè¯ç”¨æˆ·å"""
        username_pattern = re.compile(r'^[a-zA-Z0-9_]{3,20}$')

        if not username_pattern.match(username):
            raise ValidationError('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œé•¿åº¦3-20ä¸ªå­—ç¬¦')

        return username.lower()

    def validate_file_upload(self, file_obj, allowed_extensions: List[str]) -> None:
        """éªŒè¯æ–‡ä»¶ä¸Šä¼ """
        if not file_obj:
            raise ValidationError('æ–‡ä»¶ä¸èƒ½ä¸ºç©º')

        # æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
        file_name = file_obj.name.lower()
        if not any(file_name.endswith(ext) for ext in allowed_extensions):
            raise ValidationError(f'ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹ï¼Œå…è®¸çš„ç±»å‹ï¼š{", ".join(allowed_extensions)}')

        # æ£€æŸ¥æ–‡ä»¶å¤§å°
        max_size = 10 * 1024 * 1024  # 10MB
        if file_obj.size > max_size:
            raise ValidationError('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB')

        # æ£€æŸ¥æ–‡ä»¶å†…å®¹
        self._validate_file_content(file_obj)

    def _sanitize_html(self, html_content: str) -> str:
        """æ¸…ç†HTMLå†…å®¹"""
        import bleach

        allowed_tags = [
            'p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li',
            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'
        ]

        allowed_attributes = {
            '*': ['class'],
            'a': ['href', 'title'],
            'img': ['src', 'alt', 'width', 'height'],
        }

        return bleach.clean(
            html_content,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=True
        )

    def _validate_file_content(self, file_obj) -> None:
        """éªŒè¯æ–‡ä»¶å†…å®¹"""
        # è¯»å–æ–‡ä»¶å¤´éƒ¨æ£€æŸ¥æ–‡ä»¶ç±»å‹
        file_obj.seek(0)
        header = file_obj.read(1024)
        file_obj.seek(0)

        # æ£€æŸ¥æ˜¯å¦åŒ…å«å¯æ‰§è¡Œä»£ç 
        dangerous_signatures = [
            b'\x4d\x5a',  # PEæ–‡ä»¶å¤´
            b'\x7f\x45\x4c\x46',  # ELFæ–‡ä»¶å¤´
            b'\xca\xfe\xba\xbe',  # Java classæ–‡ä»¶
            b'\xfe\xed\xfa',  # Mach-Oæ–‡ä»¶
        ]

        for signature in dangerous_signatures:
            if header.startswith(signature):
                raise ValidationError('ä¸å…è®¸ä¸Šä¼ å¯æ‰§è¡Œæ–‡ä»¶')

class APIInputValidator:
    """APIè¾“å…¥éªŒè¯å™¨"""

    def __init__(self):
        self.validator = InputValidator()

    def validate_request_data(self, data: Dict[str, Any], schema: Dict[str, Dict]) -> Dict[str, Any]:
        """éªŒè¯è¯·æ±‚æ•°æ®"""
        validated_data = {}

        for field_name, field_config in schema.items():
            field_type = field_config.get('type')
            required = field_config.get('required', False)
            max_length = field_config.get('max_length')
            allow_html = field_config.get('allow_html', False)

            value = data.get(field_name)

            # å¿…å¡«å­—æ®µæ£€æŸ¥
            if required and (value is None or value == ''):
                raise ValidationError(f'{field_name}æ˜¯å¿…å¡«å­—æ®µ')

            if value is None:
                continue

            # ç±»å‹éªŒè¯
            if field_type == 'string':
                validated_data[field_name] = self.validator.validate_string(
                    value, max_length, allow_html, field_name
                )
            elif field_type == 'email':
                validated_data[field_name] = self.validator.validate_email(value)
            elif field_type == 'phone':
                validated_data[field_name] = self.validator.validate_phone(value)
            elif field_type == 'username':
                validated_data[field_name] = self.validator.validate_username(value)
            elif field_type == 'integer':
                try:
                    validated_data[field_name] = int(value)
                except (ValueError, TypeError):
                    raise ValidationError(f'{field_name}å¿…é¡»æ˜¯æ•´æ•°')
            elif field_type == 'float':
                try:
                    validated_data[field_name] = float(value)
                except (ValueError, TypeError):
                    raise ValidationError(f'{field_name}å¿…é¡»æ˜¯æ•°å­—')
            elif field_type == 'boolean':
                validated_data[field_name] = bool(value)
            else:
                validated_data[field_name] = value

        return validated_data
```

### 2. APIé€Ÿç‡é™åˆ¶

```python
# utils/rate_limiting.py
import time
from typing import Dict, Optional
from django.core.cache import cache
from django.http import HttpResponse
from rest_framework.throttling import BaseThrottle
from rest_framework.exceptions import Throttled

class EnhancedRateLimit(BaseThrottle):
    """å¢å¼ºçš„é€Ÿç‡é™åˆ¶"""

    def __init__(self):
        self.rate_limits = {
            'login': {'requests': 5, 'window': 300},  # 5æ¬¡/5åˆ†é’Ÿ
            'api_call': {'requests': 100, 'window': 60},  # 100æ¬¡/åˆ†é’Ÿ
            'file_upload': {'requests': 10, 'window': 3600},  # 10æ¬¡/å°æ—¶
            'ai_request': {'requests': 20, 'window': 3600},  # 20æ¬¡/å°æ—¶
        }

    def allow_request(self, request, view):
        """æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚"""
        # è·å–é™åˆ¶ç±»å‹
        limit_type = getattr(view, 'rate_limit_type', 'api_call')

        # è·å–å®¢æˆ·ç«¯æ ‡è¯†
        client_id = self._get_client_id(request)

        # æ£€æŸ¥é€Ÿç‡é™åˆ¶
        return self._check_rate_limit(client_id, limit_type)

    def wait(self):
        """è¿”å›ç­‰å¾…æ—¶é—´"""
        return self.next_request_time - time.time()

    def _get_client_id(self, request) -> str:
        """è·å–å®¢æˆ·ç«¯æ ‡è¯†"""
        # ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·ID
        if request.user and request.user.is_authenticated:
            return f'user:{request.user.id}'

        # ä½¿ç”¨IPåœ°å€
        ip = self._get_client_ip(request)
        return f'ip:{ip}'

    def _get_client_ip(self, request) -> str:
        """è·å–å®¢æˆ·ç«¯IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip

    def _check_rate_limit(self, client_id: str, limit_type: str) -> bool:
        """æ£€æŸ¥é€Ÿç‡é™åˆ¶"""
        if limit_type not in self.rate_limits:
            return True

        config = self.rate_limits[limit_type]
        max_requests = config['requests']
        window = config['window']

        # ç¼“å­˜é”®
        cache_key = f'rate_limit:{limit_type}:{client_id}'

        # è·å–å½“å‰è®¡æ•°
        current_time = time.time()
        request_data = cache.get(cache_key, {'count': 0, 'window_start': current_time})

        # æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®çª—å£
        if current_time - request_data['window_start'] >= window:
            request_data = {'count': 0, 'window_start': current_time}

        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        if request_data['count'] >= max_requests:
            self.next_request_time = request_data['window_start'] + window
            return False

        # å¢åŠ è®¡æ•°
        request_data['count'] += 1
        cache.set(cache_key, request_data, timeout=window)

        return True

class AdaptiveRateLimit(BaseThrottle):
    """è‡ªé€‚åº”é€Ÿç‡é™åˆ¶"""

    def __init__(self):
        self.base_limits = {
            'trusted_user': {'requests': 200, 'window': 60},
            'normal_user': {'requests': 100, 'window': 60},
            'suspicious_user': {'requests': 20, 'window': 60},
            'blocked_user': {'requests': 0, 'window': 60},
        }

    def allow_request(self, request, view):
        """è‡ªé€‚åº”é€Ÿç‡é™åˆ¶æ£€æŸ¥"""
        client_id = self._get_client_id(request)
        user_tier = self._get_user_tier(request)

        # æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­
        if self._is_blacklisted(client_id):
            return False

        # æ ¹æ®ç”¨æˆ·ç­‰çº§è°ƒæ•´é™åˆ¶
        limit_config = self.base_limits.get(user_tier, self.base_limits['normal_user'])

        return self._check_adaptive_limit(client_id, limit_config, request)

    def _get_user_tier(self, request) -> str:
        """è·å–ç”¨æˆ·ç­‰çº§"""
        if not request.user or not request.user.is_authenticated:
            return 'normal_user'

        # æ£€æŸ¥ç”¨æˆ·ä¿¡èª‰åº¦
        trust_score = self._calculate_trust_score(request.user)

        if trust_score >= 90:
            return 'trusted_user'
        elif trust_score >= 50:
            return 'normal_user'
        elif trust_score >= 20:
            return 'suspicious_user'
        else:
            return 'blocked_user'

    def _calculate_trust_score(self, user) -> int:
        """è®¡ç®—ç”¨æˆ·ä¿¡èª‰åº¦"""
        score = 50  # åŸºç¡€åˆ†æ•°

        # è´¦æˆ·å¹´é¾„åŠ åˆ†
        account_age_days = (timezone.now() - user.date_joined).days
        score += min(account_age_days // 30, 20)  # æ¯æœˆ+1åˆ†ï¼Œæœ€å¤š20åˆ†

        # æ´»è·ƒåº¦åŠ åˆ†
        recent_activity = self._get_recent_activity_score(user)
        score += recent_activity

        # è¿è§„è®°å½•æ‰£åˆ†
        violation_count = self._get_violation_count(user)
        score -= violation_count * 10

        return max(0, min(100, score))

    def _get_recent_activity_score(self, user) -> int:
        """è·å–æœ€è¿‘æ´»åŠ¨åˆ†æ•°"""
        # è¿™é‡Œå¯ä»¥æ ¹æ®ç”¨æˆ·æœ€è¿‘çš„æ´»åŠ¨æƒ…å†µè®¡ç®—åˆ†æ•°
        # ä¾‹å¦‚ï¼šç™»å½•é¢‘ç‡ã€APIè°ƒç”¨æˆåŠŸç‡ç­‰
        return 10  # ç®€åŒ–å®ç°

    def _get_violation_count(self, user) -> int:
        """è·å–è¿è§„æ¬¡æ•°"""
        from monitoring.models import SecurityEvent

        return SecurityEvent.objects.filter(
            user=user,
            event_type__in=['rate_limit_exceeded', 'suspicious_activity'],
            created_at__gte=timezone.now() - timedelta(days=30)
        ).count()

    def _is_blacklisted(self, client_id: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­"""
        blacklist_key = f'blacklist:{client_id}'
        return cache.get(blacklist_key, False)

    def _check_adaptive_limit(
        self,
        client_id: str,
        limit_config: Dict[str, int],
        request
    ) -> bool:
        """æ£€æŸ¥è‡ªé€‚åº”é™åˆ¶"""
        max_requests = limit_config['requests']
        window = limit_config['window']

        if max_requests == 0:
            return False

        cache_key = f'adaptive_limit:{client_id}'
        current_time = time.time()

        request_data = cache.get(cache_key, {
            'count': 0,
            'window_start': current_time,
            'violations': 0
        })

        # é‡ç½®çª—å£
        if current_time - request_data['window_start'] >= window:
            request_data = {
                'count': 0,
                'window_start': current_time,
                'violations': max(0, request_data['violations'] - 1)  # è¿è§„æ¬¡æ•°è¡°å‡
            }

        # åŠ¨æ€è°ƒæ•´é™åˆ¶
        adjusted_limit = max_requests - (request_data['violations'] * 10)

        if request_data['count'] >= adjusted_limit:
            # è®°å½•è¿è§„
            request_data['violations'] += 1
            cache.set(cache_key, request_data, timeout=window * 2)

            # ä¸¥é‡è¿è§„æ—¶åŠ å…¥é»‘åå•
            if request_data['violations'] >= 5:
                blacklist_key = f'blacklist:{client_id}'
                cache.set(blacklist_key, True, timeout=3600)  # 1å°æ—¶é»‘åå•

            return False

        request_data['count'] += 1
        cache.set(cache_key, request_data, timeout=window)

        return True
```

---

## ğŸ” å®‰å…¨ç›‘æ§å’Œå®¡è®¡

### 1. å®‰å…¨äº‹ä»¶ç›‘æ§

```python
# monitoring/security_monitor.py
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from django.contrib.auth import get_user_model
from django.core.cache import cache
from django.db import models
from enum import Enum

User = get_user_model()
security_logger = logging.getLogger('security')

class SecurityEventType(Enum):
    """å®‰å…¨äº‹ä»¶ç±»å‹"""
    LOGIN_SUCCESS = 'login_success'
    LOGIN_FAILURE = 'login_failure'
    LOGOUT = 'logout'
    PASSWORD_CHANGE = 'password_change'
    PERMISSION_DENIED = 'permission_denied'
    RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded'
    SUSPICIOUS_ACTIVITY = 'suspicious_activity'
    DATA_ACCESS = 'data_access'
    DATA_MODIFICATION = 'data_modification'
    FILE_UPLOAD = 'file_upload'
    API_ABUSE = 'api_abuse'
    SECURITY_VIOLATION = 'security_violation'

class SecuritySeverity(Enum):
    """å®‰å…¨äº‹ä»¶ä¸¥é‡ç¨‹åº¦"""
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    CRITICAL = 'critical'

class SecurityEvent(models.Model):
    """å®‰å…¨äº‹ä»¶æ¨¡å‹"""

    event_type = models.CharField(
        max_length=50,
        choices=[(e.value, e.value) for e in SecurityEventType],
        verbose_name='äº‹ä»¶ç±»å‹'
    )
    severity = models.CharField(
        max_length=20,
        choices=[(s.value, s.value) for s in SecuritySeverity],
        default=SecuritySeverity.LOW.value,
        verbose_name='ä¸¥é‡ç¨‹åº¦'
    )
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='ç›¸å…³ç”¨æˆ·'
    )
    ip_address = models.GenericIPAddressField(
        null=True,
        blank=True,
        verbose_name='IPåœ°å€'
    )
    user_agent = models.TextField(
        null=True,
        blank=True,
        verbose_name='ç”¨æˆ·ä»£ç†'
    )
    session_id = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        verbose_name='ä¼šè¯ID'
    )
    details = models.JSONField(
        default=dict,
        verbose_name='äº‹ä»¶è¯¦æƒ…'
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name='åˆ›å»ºæ—¶é—´'
    )

    class Meta:
        db_table = 'security_events'
        verbose_name = 'å®‰å…¨äº‹ä»¶'
        verbose_name_plural = 'å®‰å…¨äº‹ä»¶'
        indexes = [
            models.Index(fields=['event_type', 'created_at']),
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['ip_address', 'created_at']),
            models.Index(fields=['severity', 'created_at']),
        ]

class SecurityMonitor:
    """å®‰å…¨ç›‘æ§å™¨"""

    def __init__(self):
        self.alert_thresholds = {
            SecurityEventType.LOGIN_FAILURE: {'count': 5, 'window': 300},
            SecurityEventType.RATE_LIMIT_EXCEEDED: {'count': 3, 'window': 600},
            SecurityEventType.PERMISSION_DENIED: {'count': 10, 'window': 300},
            SecurityEventType.SUSPICIOUS_ACTIVITY: {'count': 1, 'window': 60},
        }

    def log_event(
        self,
        event_type: SecurityEventType,
        severity: SecuritySeverity = SecuritySeverity.LOW,
        user: User = None,
        ip_address: str = None,
        user_agent: str = None,
        session_id: str = None,
        details: Dict[str, Any] = None
    ) -> SecurityEvent:
        """è®°å½•å®‰å…¨äº‹ä»¶"""

        event = SecurityEvent.objects.create(
            event_type=event_type.value,
            severity=severity.value,
            user=user,
            ip_address=ip_address,
            user_agent=user_agent,
            session_id=session_id,
            details=details or {}
        )

        # è®°å½•åˆ°æ—¥å¿—
        security_logger.info(
            f'Security Event: {event_type.value} | '
            f'Severity: {severity.value} | '
            f'User: {user.username if user else "Anonymous"} | '
            f'IP: {ip_address} | '
            f'Details: {json.dumps(details or {})}'
        )

        # æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
        self._check_alert_conditions(event)

        return event

    def _check_alert_conditions(self, event: SecurityEvent) -> None:
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        event_type = SecurityEventType(event.event_type)

        if event_type not in self.alert_thresholds:
            return

        threshold = self.alert_thresholds[event_type]
        time_window = timedelta(seconds=threshold['window'])
        since_time = datetime.now() - time_window

        # ç»Ÿè®¡æ—¶é—´çª—å£å†…çš„äº‹ä»¶æ•°é‡
        recent_events = SecurityEvent.objects.filter(
            event_type=event.event_type,
            created_at__gte=since_time
        )

        # æŒ‰ç”¨æˆ·æˆ–IPåˆ†ç»„ç»Ÿè®¡
        if event.user:
            recent_events = recent_events.filter(user=event.user)
            identifier = f'user:{event.user.username}'
        elif event.ip_address:
            recent_events = recent_events.filter(ip_address=event.ip_address)
            identifier = f'ip:{event.ip_address}'
        else:
            return

        event_count = recent_events.count()

        if event_count >= threshold['count']:
            self._trigger_alert(event_type, identifier, event_count, threshold)

    def _trigger_alert(
        self,
        event_type: SecurityEventType,
        identifier: str,
        event_count: int,
        threshold: Dict[str, int]
    ) -> None:
        """è§¦å‘å®‰å…¨å‘Šè­¦"""
        alert_key = f'security_alert:{event_type.value}:{identifier}'

        # é˜²æ­¢é‡å¤å‘Šè­¦
        if cache.get(alert_key):
            return

        # è®¾ç½®å‘Šè­¦å†·å´æ—¶é—´
        cache.set(alert_key, True, timeout=threshold['window'])

        # å‘é€å‘Šè­¦
        alert_message = (
            f'å®‰å…¨å‘Šè­¦: {event_type.value} äº‹ä»¶é¢‘ç¹å‘ç”Ÿ\n'
            f'æ ‡è¯†ç¬¦: {identifier}\n'
            f'äº‹ä»¶æ•°é‡: {event_count}\n'
            f'æ—¶é—´çª—å£: {threshold["window"]}ç§’\n'
            f'é˜ˆå€¼: {threshold["count"]}æ¬¡'
        )

        # è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€çŸ­ä¿¡ã€é’‰é’‰ç­‰å‘Šè­¦æ–¹å¼
        self._send_alert(alert_message, event_type)

    def _send_alert(self, message: str, event_type: SecurityEventType) -> None:
        """å‘é€å‘Šè­¦æ¶ˆæ¯"""
        # è®°å½•åˆ°é«˜ä¼˜å…ˆçº§æ—¥å¿—
        security_logger.critical(f'SECURITY ALERT: {message}')

        # å¯ä»¥åœ¨è¿™é‡Œé›†æˆå…·ä½“çš„å‘Šè­¦æ¸ é“
        # ä¾‹å¦‚ï¼šé‚®ä»¶ã€çŸ­ä¿¡ã€Slackã€é’‰é’‰ç­‰
        pass

class AuditLogger:
    """å®¡è®¡æ—¥å¿—è®°å½•å™¨"""

    def __init__(self):
        self.audit_logger = logging.getLogger('audit')

    def log_data_access(
        self,
        user: User,
        resource_type: str,
        resource_id: str,
        action: str,
        ip_address: str = None,
        details: Dict[str, Any] = None
    ) -> None:
        """è®°å½•æ•°æ®è®¿é—®"""
        audit_data = {
            'timestamp': datetime.now().isoformat(),
            'user_id': user.id,
            'username': user.username,
            'resource_type': resource_type,
            'resource_id': resource_id,
            'action': action,
            'ip_address': ip_address,
            'details': details or {}
        }

        self.audit_logger.info(json.dumps(audit_data))

    def log_admin_action(
        self,
        admin_user: User,
        action: str,
        target_user: User = None,
        details: Dict[str, Any] = None
    ) -> None:
        """è®°å½•ç®¡ç†å‘˜æ“ä½œ"""
        audit_data = {
            'timestamp': datetime.now().isoformat(),
            'admin_user_id': admin_user.id,
            'admin_username': admin_user.username,
            'action': action,
            'target_user_id': target_user.id if target_user else None,
            'target_username': target_user.username if target_user else None,
            'details': details or {}
        }

        self.audit_logger.warning(json.dumps(audit_data))
```

### 2. æ¼æ´æ‰«æå’Œæ£€æµ‹

```python
# security/vulnerability_scanner.py
import re
import subprocess
from typing import List, Dict, Any
from pathlib import Path
from dataclasses import dataclass

@dataclass
class Vulnerability:
    """æ¼æ´ä¿¡æ¯"""
    severity: str
    category: str
    description: str
    file_path: str
    line_number: int
    recommendation: str

class VulnerabilityScanner:
    """æ¼æ´æ‰«æå™¨"""

    def __init__(self):
        self.security_patterns = {
            'sql_injection': [
                r'\bexecute\s*\(.*%.*\)',
                r'\bcursor\.execute\s*\(.*\+.*\)',
                r'\braw\s*\(.*\+.*\)',
            ],
            'xss': [
                r'\bmark_safe\s*\(',
                r'\|safe\b',
                r'\brender_to_string\s*\(.*\+.*\)',
            ],
            'path_traversal': [
                r'\bopen\s*\(.*\+.*\)',
                r'\bfile\s*\(.*\+.*\)',
                r'\.\./',
            ],
            'hardcoded_secrets': [
                r'password\s*=\s*["\'][^"\'
]{8,}["\']',
                r'secret\s*=\s*["\'][^"\'
]{16,}["\']',
                r'api_key\s*=\s*["\'][^"\'
]{16,}["\']',
            ],
            'weak_crypto': [
                r'\bmd5\s*\(',
                r'\bsha1\s*\(',
                r'\bDES\b',
                r'\bRC4\b',
            ]
        }

    def scan_codebase(self, project_path: Path) -> List[Vulnerability]:
        """æ‰«æä»£ç åº“"""
        vulnerabilities = []

        # æ‰«æPythonæ–‡ä»¶
        for py_file in project_path.rglob('*.py'):
            vulnerabilities.extend(self._scan_file(py_file))

        # æ‰«ææ¨¡æ¿æ–‡ä»¶
        for template_file in project_path.rglob('*.html'):
            vulnerabilities.extend(self._scan_template(template_file))

        # æ‰«æé…ç½®æ–‡ä»¶
        for config_file in project_path.rglob('*.env'):
            vulnerabilities.extend(self._scan_config(config_file))

        return vulnerabilities

    def _scan_file(self, file_path: Path) -> List[Vulnerability]:
        """æ‰«æPythonæ–‡ä»¶"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            for category, patterns in self.security_patterns.items():
                for pattern in patterns:
                    for line_num, line in enumerate(lines, 1):
                        if re.search(pattern, line, re.IGNORECASE):
                            vulnerability = Vulnerability(
                                severity=self._get_severity(category),
                                category=category,
                                description=self._get_description(category),
                                file_path=str(file_path),
                                line_number=line_num,
                                recommendation=self._get_recommendation(category)
                            )
                            vulnerabilities.append(vulnerability)

        except Exception as e:
            print(f"æ‰«ææ–‡ä»¶ {file_path} æ—¶å‡ºé”™: {e}")

        return vulnerabilities

    def _scan_template(self, file_path: Path) -> List[Vulnerability]:
        """æ‰«ææ¨¡æ¿æ–‡ä»¶"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            # æ£€æŸ¥XSSæ¼æ´
            xss_patterns = [
                r'\{\{.*\|safe.*\}\}',
                r'\{\%.*autoescape\s+off.*\%\}',
            ]

            for pattern in xss_patterns:
                for line_num, line in enumerate(lines, 1):
                    if re.search(pattern, line):
                        vulnerability = Vulnerability(
                            severity='high',
                            category='xss',
                            description='æ¨¡æ¿ä¸­å¯èƒ½å­˜åœ¨XSSæ¼æ´',
                            file_path=str(file_path),
                            line_number=line_num,
                            recommendation='ä½¿ç”¨Djangoçš„è‡ªåŠ¨è½¬ä¹‰åŠŸèƒ½ï¼Œé¿å…ä½¿ç”¨|safeè¿‡æ»¤å™¨'
                        )
                        vulnerabilities.append(vulnerability)

        except Exception as e:
            print(f"æ‰«ææ¨¡æ¿æ–‡ä»¶ {file_path} æ—¶å‡ºé”™: {e}")

        return vulnerabilities

    def _scan_config(self, file_path: Path) -> List[Vulnerability]:
        """æ‰«æé…ç½®æ–‡ä»¶"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            # æ£€æŸ¥ç¡¬ç¼–ç å¯†é’¥
            for line_num, line in enumerate(lines, 1):
                if re.search(r'\w+\s*=\s*["\'][^"\'
]{16,}["\']', line):
                    vulnerability = Vulnerability(
                        severity='critical',
                        category='hardcoded_secrets',
                        description='é…ç½®æ–‡ä»¶ä¸­å‘ç°ç¡¬ç¼–ç å¯†é’¥',
                        file_path=str(file_path),
                        line_number=line_num,
                        recommendation='ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡å­˜å‚¨æ•æ„Ÿä¿¡æ¯'
                    )
                    vulnerabilities.append(vulnerability)

        except Exception as e:
            print(f"æ‰«æé…ç½®æ–‡ä»¶ {file_path} æ—¶å‡ºé”™: {e}")

        return vulnerabilities

    def _get_severity(self, category: str) -> str:
        """è·å–æ¼æ´ä¸¥é‡ç¨‹åº¦"""
        severity_map = {
            'sql_injection': 'critical',
            'xss': 'high',
            'path_traversal': 'high',
            'hardcoded_secrets': 'critical',
            'weak_crypto': 'medium'
        }
        return severity_map.get(category, 'low')

    def _get_description(self, category: str) -> str:
        """è·å–æ¼æ´æè¿°"""
        descriptions = {
            'sql_injection': 'SQLæ³¨å…¥æ¼æ´ï¼šå¯èƒ½å…è®¸æ”»å‡»è€…æ‰§è¡Œæ¶æ„SQLè¯­å¥',
            'xss': 'è·¨ç«™è„šæœ¬æ”»å‡»æ¼æ´ï¼šå¯èƒ½å…è®¸æ”»å‡»è€…æ³¨å…¥æ¶æ„è„šæœ¬',
            'path_traversal': 'è·¯å¾„éå†æ¼æ´ï¼šå¯èƒ½å…è®¸æ”»å‡»è€…è®¿é—®ç³»ç»Ÿæ–‡ä»¶',
            'hardcoded_secrets': 'ç¡¬ç¼–ç å¯†é’¥ï¼šæ•æ„Ÿä¿¡æ¯æš´éœ²åœ¨ä»£ç ä¸­',
            'weak_crypto': 'å¼±åŠ å¯†ç®—æ³•ï¼šä½¿ç”¨äº†ä¸å®‰å…¨çš„åŠ å¯†æ–¹æ³•'
        }
        return descriptions.get(category, 'æœªçŸ¥æ¼æ´ç±»å‹')

    def _get_recommendation(self, category: str) -> str:
        """è·å–ä¿®å¤å»ºè®®"""
        recommendations = {
            'sql_injection': 'ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢æˆ–ORMï¼Œé¿å…å­—ç¬¦ä¸²æ‹¼æ¥',
            'xss': 'ä½¿ç”¨Djangoçš„è‡ªåŠ¨è½¬ä¹‰åŠŸèƒ½ï¼Œå¯¹ç”¨æˆ·è¾“å…¥è¿›è¡ŒéªŒè¯å’Œæ¸…ç†',
            'path_traversal': 'éªŒè¯æ–‡ä»¶è·¯å¾„ï¼Œä½¿ç”¨å®‰å…¨çš„æ–‡ä»¶æ“ä½œæ–¹æ³•',
            'hardcoded_secrets': 'ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡å­˜å‚¨æ•æ„Ÿä¿¡æ¯',
            'weak_crypto': 'ä½¿ç”¨å¼ºåŠ å¯†ç®—æ³•ï¼Œå¦‚AES-256ã€SHA-256ç­‰'
        }
        return recommendations.get(category, 'è¯·å’¨è¯¢å®‰å…¨ä¸“å®¶')

    def generate_report(self, vulnerabilities: List[Vulnerability]) -> str:
        """ç”Ÿæˆæ‰«ææŠ¥å‘Š"""
        if not vulnerabilities:
            return "æœªå‘ç°å®‰å…¨æ¼æ´"

        report = "# å®‰å…¨æ¼æ´æ‰«ææŠ¥å‘Š\n\n"

        # æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„
        by_severity = {}
        for vuln in vulnerabilities:
            if vuln.severity not in by_severity:
                by_severity[vuln.severity] = []
            by_severity[vuln.severity].append(vuln)

        # ç”ŸæˆæŠ¥å‘Š
        severity_order = ['critical', 'high', 'medium', 'low']
        for severity in severity_order:
            if severity in by_severity:
                report += f"## {severity.upper()} çº§åˆ«æ¼æ´ ({len(by_severity[severity])}ä¸ª)\n\n"

                for vuln in by_severity[severity]:
                    report += f"### {vuln.category}\n"
                    report += f"- **æ–‡ä»¶**: {vuln.file_path}:{vuln.line_number}\n"
                    report += f"- **æè¿°**: {vuln.description}\n"
                    report += f"- **å»ºè®®**: {vuln.recommendation}\n\n"

        return report

class DependencyScanner:
    """ä¾èµ–æ¼æ´æ‰«æå™¨"""

    def scan_dependencies(self, requirements_file: Path) -> List[Dict[str, Any]]:
        """æ‰«æä¾èµ–æ¼æ´"""
        vulnerabilities = []

        try:
            # ä½¿ç”¨safetyå·¥å…·æ‰«æPythonä¾èµ–
            result = subprocess.run(
                ['safety', 'check', '-r', str(requirements_file), '--json'],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                import json
                safety_data = json.loads(result.stdout)

                for vuln in safety_data:
                    vulnerabilities.append({
                        'package': vuln.get('package'),
                        'version': vuln.get('installed_version'),
                        'vulnerability_id': vuln.get('vulnerability_id'),
                        'description': vuln.get('advisory'),
                        'severity': 'high'  # Safetyé€šå¸¸æŠ¥å‘Šé«˜å±æ¼æ´
                    })

        except Exception as e:
            print(f"ä¾èµ–æ‰«æå¤±è´¥: {e}")

        return vulnerabilities
```

---

## ğŸ“‹ åˆè§„æ€§æ£€æŸ¥

### 1. æ•°æ®ä¿æŠ¤åˆè§„

```python
# compliance/gdpr_compliance.py
from typing import Dict, List, Any
from django.contrib.auth import get_user_model
from django.db import models
from datetime import datetime, timedelta

User = get_user_model()

class DataProtectionCompliance:
    """æ•°æ®ä¿æŠ¤åˆè§„æ£€æŸ¥"""

    def __init__(self):
        self.retention_policies = {
            'user_data': 365 * 7,  # 7å¹´
            'learning_records': 365 * 5,  # 5å¹´
            'log_data': 365 * 2,  # 2å¹´
            'session_data': 30,  # 30å¤©
        }

    def check_data_retention(self) -> Dict[str, Any]:
        """æ£€æŸ¥æ•°æ®ä¿ç•™åˆè§„æ€§"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # æ£€æŸ¥ç”¨æˆ·æ•°æ®ä¿ç•™
        old_users = User.objects.filter(
            last_login__lt=datetime.now() - timedelta(days=self.retention_policies['user_data']),
            is_active=False
        )

        if old_users.exists():
            compliance_report['issues'].append({
                'type': 'data_retention',
                'description': f'å‘ç°{old_users.count()}ä¸ªè¶…è¿‡ä¿ç•™æœŸé™çš„ç”¨æˆ·è´¦æˆ·',
                'severity': 'medium'
            })
            compliance_report['recommendations'].append(
                'å»ºè®®æ¸…ç†è¶…è¿‡ä¿ç•™æœŸé™çš„ç”¨æˆ·æ•°æ®'
            )

        return compliance_report

    def check_consent_management(self) -> Dict[str, Any]:
        """æ£€æŸ¥ç”¨æˆ·åŒæ„ç®¡ç†"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # æ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·åŒæ„è®°å½•
        users_without_consent = User.objects.filter(
            consent_records__isnull=True
        )

        if users_without_consent.exists():
            compliance_report['compliant'] = False
            compliance_report['issues'].append({
                'type': 'missing_consent',
                'description': f'{users_without_consent.count()}ä¸ªç”¨æˆ·ç¼ºå°‘åŒæ„è®°å½•',
                'severity': 'high'
            })

        return compliance_report

    def generate_privacy_report(self, user: User) -> Dict[str, Any]:
        """ç”Ÿæˆç”¨æˆ·éšç§æŠ¥å‘Š"""
        report = {
            'user_id': user.id,
            'data_collected': [],
            'processing_purposes': [],
            'data_sharing': [],
            'retention_periods': {}
        }

        # æ”¶é›†ç”¨æˆ·æ•°æ®ä¿¡æ¯
        report['data_collected'] = [
            'åŸºæœ¬ä¿¡æ¯ï¼ˆå§“åã€é‚®ç®±ã€æ‰‹æœºå·ï¼‰',
            'å­¦ä¹ è®°å½•å’Œè¿›åº¦',
            'ç³»ç»Ÿä½¿ç”¨æ—¥å¿—',
            'è®¾å¤‡å’Œæµè§ˆå™¨ä¿¡æ¯'
        ]

        report['processing_purposes'] = [
            'æä¾›æ•™è‚²æœåŠ¡',
            'ä¸ªæ€§åŒ–å­¦ä¹ æ¨è',
            'ç³»ç»Ÿå®‰å…¨å’Œç»´æŠ¤',
            'æœåŠ¡æ”¹è¿›å’Œåˆ†æ'
        ]

        return report

class SecurityCompliance:
    """å®‰å…¨åˆè§„æ£€æŸ¥"""

    def check_password_policy(self) -> Dict[str, Any]:
        """æ£€æŸ¥å¯†ç ç­–ç•¥åˆè§„æ€§"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # æ£€æŸ¥å¯†ç ç­–ç•¥é…ç½®
        from django.conf import settings

        password_validators = getattr(settings, 'AUTH_PASSWORD_VALIDATORS', [])

        required_validators = [
            'MinimumLengthValidator',
            'CommonPasswordValidator',
            'NumericPasswordValidator'
        ]

        configured_validators = [
            validator['NAME'].split('.')[-1]
            for validator in password_validators
        ]

        for required in required_validators:
            if required not in configured_validators:
                compliance_report['compliant'] = False
                compliance_report['issues'].append({
                    'type': 'missing_password_validator',
                    'description': f'ç¼ºå°‘å¯†ç éªŒè¯å™¨: {required}',
                    'severity': 'medium'
                })

        return compliance_report

    def check_encryption_compliance(self) -> Dict[str, Any]:
        """æ£€æŸ¥åŠ å¯†åˆè§„æ€§"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # æ£€æŸ¥HTTPSé…ç½®
        from django.conf import settings

        if not getattr(settings, 'SECURE_SSL_REDIRECT', False):
            compliance_report['compliant'] = False
            compliance_report['issues'].append({
                'type': 'missing_https_redirect',
                'description': 'æœªå¯ç”¨HTTPSé‡å®šå‘',
                'severity': 'high'
            })

        # æ£€æŸ¥ä¼šè¯å®‰å…¨
        if not getattr(settings, 'SESSION_COOKIE_SECURE', False):
            compliance_report['compliant'] = False
            compliance_report['issues'].append({
                'type': 'insecure_session_cookie',
                'description': 'ä¼šè¯Cookieæœªè®¾ç½®Secureæ ‡å¿—',
                'severity': 'medium'
            })

        return compliance_report
```

---

## ğŸ“… å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šåŸºç¡€å®‰å…¨åŠ å›º (2å‘¨)

**ç›®æ ‡**: ä¿®å¤é«˜å±å®‰å…¨æ¼æ´ï¼Œå»ºç«‹åŸºç¡€é˜²æŠ¤

| ä»»åŠ¡         | è´Ÿè´£äºº     | å·¥æœŸ | éªŒæ”¶æ ‡å‡†                 |
| ------------ | ---------- | ---- | ------------------------ |
| èº«ä»½è®¤è¯å¢å¼º | åç«¯å¼€å‘   | 3å¤©  | MFAåŠŸèƒ½å¯ç”¨ï¼ŒJWTå®‰å…¨é…ç½® |
| è¾“å…¥éªŒè¯å®Œå–„ | åç«¯å¼€å‘   | 2å¤©  | æ‰€æœ‰APIæ¥å£è¾“å…¥éªŒè¯      |
| æ•°æ®åŠ å¯†å®æ–½ | åç«¯å¼€å‘   | 4å¤©  | æ•æ„Ÿå­—æ®µåŠ å¯†å­˜å‚¨         |
| HTTPSé…ç½®    | è¿ç»´å·¥ç¨‹å¸ˆ | 1å¤©  | å…¨ç«™HTTPSï¼Œå®‰å…¨å¤´éƒ¨é…ç½®  |
| å¯†ç ç­–ç•¥æ›´æ–° | åç«¯å¼€å‘   | 1å¤©  | å¼ºå¯†ç ç­–ç•¥ç”Ÿæ•ˆ           |

### é˜¶æ®µäºŒï¼šè®¿é—®æ§åˆ¶ä¼˜åŒ– (2å‘¨)

**ç›®æ ‡**: å®ç°ç»†ç²’åº¦æƒé™æ§åˆ¶å’Œä¼šè¯ç®¡ç†

| ä»»åŠ¡         | è´Ÿè´£äºº   | å·¥æœŸ | éªŒæ”¶æ ‡å‡†             |
| ------------ | -------- | ---- | -------------------- |
| æƒé™ç³»ç»Ÿé‡æ„ | åç«¯å¼€å‘ | 5å¤©  | ç»†ç²’åº¦æƒé™æ§åˆ¶       |
| ä¼šè¯ç®¡ç†å¢å¼º | åç«¯å¼€å‘ | 3å¤©  | å¤šä¼šè¯ç®¡ç†ï¼Œå¼‚å¸¸æ£€æµ‹ |
| APIé€Ÿç‡é™åˆ¶  | åç«¯å¼€å‘ | 2å¤©  | è‡ªé€‚åº”é€Ÿç‡é™åˆ¶       |
| å®‰å…¨ä¸­é—´ä»¶   | åç«¯å¼€å‘ | 2å¤©  | å®‰å…¨æ£€æŸ¥ä¸­é—´ä»¶       |

### é˜¶æ®µä¸‰ï¼šç›‘æ§å’Œå®¡è®¡ (2å‘¨)

**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„å®‰å…¨ç›‘æ§å’Œå®¡è®¡ä½“ç³»

| ä»»åŠ¡           | è´Ÿè´£äºº     | å·¥æœŸ | éªŒæ”¶æ ‡å‡†       |
| -------------- | ---------- | ---- | -------------- |
| å®‰å…¨äº‹ä»¶ç›‘æ§   | åç«¯å¼€å‘   | 4å¤©  | å®æ—¶å®‰å…¨ç›‘æ§   |
| å®¡è®¡æ—¥å¿—ç³»ç»Ÿ   | åç«¯å¼€å‘   | 3å¤©  | å®Œæ•´å®¡è®¡æ—¥å¿—   |
| å‘Šè­¦ç³»ç»Ÿé›†æˆ   | è¿ç»´å·¥ç¨‹å¸ˆ | 2å¤©  | å¤šæ¸ é“å®‰å…¨å‘Šè­¦ |
| æ¼æ´æ‰«æè‡ªåŠ¨åŒ– | DevOps     | 3å¤©  | è‡ªåŠ¨åŒ–å®‰å…¨æ‰«æ |

### é˜¶æ®µå››ï¼šåˆè§„æ€§å’Œæµ‹è¯• (2å‘¨)

**ç›®æ ‡**: ç¡®ä¿åˆè§„æ€§è¦æ±‚ï¼Œå®Œæˆå®‰å…¨æµ‹è¯•

| ä»»åŠ¡       | è´Ÿè´£äºº   | å·¥æœŸ | éªŒæ”¶æ ‡å‡†         |
| ---------- | -------- | ---- | ---------------- |
| åˆè§„æ€§æ£€æŸ¥ | å®‰å…¨ä¸“å®¶ | 3å¤©  | é€šè¿‡åˆè§„æ€§å®¡è®¡   |
| æ¸—é€æµ‹è¯•   | å®‰å…¨ä¸“å®¶ | 4å¤©  | æ— é«˜å±æ¼æ´       |
| å®‰å…¨åŸ¹è®­   | é¡¹ç›®ç»ç† | 2å¤©  | å›¢é˜Ÿå®‰å…¨æ„è¯†æå‡ |
| æ–‡æ¡£å®Œå–„   | æŠ€æœ¯å†™ä½œ | 3å¤©  | å®Œæ•´å®‰å…¨æ–‡æ¡£     |

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶

- [ ] **èº«ä»½è®¤è¯**: MFAåŠŸèƒ½æ­£å¸¸ï¼ŒJWTå®‰å…¨é…ç½®
- [ ] **æƒé™æ§åˆ¶**: ç»†ç²’åº¦æƒé™æ§åˆ¶ï¼Œè§’è‰²æƒé™åˆ†ç¦»
- [ ] **æ•°æ®ä¿æŠ¤**: æ•æ„Ÿæ•°æ®åŠ å¯†ï¼Œå®‰å…¨ä¼ è¾“
- [ ] **è¾“å…¥éªŒè¯**: æ‰€æœ‰è¾“å…¥ç‚¹éªŒè¯ï¼ŒXSS/SQLæ³¨å…¥é˜²æŠ¤
- [ ] **ä¼šè¯ç®¡ç†**: å®‰å…¨ä¼šè¯ç®¡ç†ï¼Œå¼‚å¸¸æ£€æµ‹
- [ ] **APIå®‰å…¨**: é€Ÿç‡é™åˆ¶ï¼Œå®‰å…¨å¤´éƒ¨é…ç½®
- [ ] **ç›‘æ§å®¡è®¡**: å®æ—¶å®‰å…¨ç›‘æ§ï¼Œå®Œæ•´å®¡è®¡æ—¥å¿—

### æ€§èƒ½éªŒæ”¶

- [ ] **å“åº”æ—¶é—´**: å®‰å…¨æ£€æŸ¥ä¸å½±å“APIå“åº”æ—¶é—´(<100ms)
- [ ] **ååé‡**: ç³»ç»Ÿååé‡ä¸é™ä½è¶…è¿‡5%
- [ ] **èµ„æºæ¶ˆè€—**: å®‰å…¨åŠŸèƒ½èµ„æºæ¶ˆè€—<10%

### å®‰å…¨éªŒæ”¶

- [ ] **æ¼æ´æ‰«æ**: æ— é«˜å±å’Œä¸¥é‡æ¼æ´
- [ ] **æ¸—é€æµ‹è¯•**: é€šè¿‡ç¬¬ä¸‰æ–¹å®‰å…¨æµ‹è¯•
- [ ] **åˆè§„æ£€æŸ¥**: æ»¡è¶³æ•°æ®ä¿æŠ¤æ³•è§„è¦æ±‚
- [ ] **å®‰å…¨è¯„ä¼°**: å®‰å…¨é£é™©ç­‰çº§é™è‡³å¯æ¥å—èŒƒå›´

---

## ğŸ“Š é£é™©è¯„ä¼°

### å®æ–½é£é™©

| é£é™©é¡¹           | æ¦‚ç‡ | å½±å“ | é£é™©ç­‰çº§ | åº”å¯¹æªæ–½             |
| ---------------- | ---- | ---- | -------- | -------------------- |
| **æ€§èƒ½å½±å“**     | ä¸­   | ä¸­   | ğŸŸ¡ ä¸­    | æ€§èƒ½æµ‹è¯•ï¼Œä¼˜åŒ–é…ç½®   |
| **å…¼å®¹æ€§é—®é¢˜**   | ä½   | é«˜   | ğŸŸ¡ ä¸­    | å……åˆ†æµ‹è¯•ï¼Œæ¸è¿›å¼éƒ¨ç½² |
| **ç”¨æˆ·ä½“éªŒå½±å“** | ä¸­   | ä¸­   | ğŸŸ¡ ä¸­    | ç”¨æˆ·åŸ¹è®­ï¼Œç•Œé¢ä¼˜åŒ–   |
| **å®æ–½å»¶æœŸ**     | ä¸­   | ä¸­   | ğŸŸ¡ ä¸­    | åˆç†æ’æœŸï¼Œèµ„æºä¿éšœ   |

### å®‰å…¨é£é™©

| é£é™©é¡¹       | å½“å‰ç­‰çº§ | ç›®æ ‡ç­‰çº§ | æ”¹è¿›æªæ–½           |
| ------------ | -------- | -------- | ------------------ |
| **æ•°æ®æ³„éœ²** | ğŸ”´ é«˜    | ğŸŸ¢ ä½    | æ•°æ®åŠ å¯†ï¼Œè®¿é—®æ§åˆ¶ |
| **èº«ä»½å†’ç”¨** | ğŸŸ¡ ä¸­    | ğŸŸ¢ ä½    | MFAï¼Œä¼šè¯ç®¡ç†      |
| **æƒé™æå‡** | ğŸŸ¡ ä¸­    | ğŸŸ¢ ä½    | ç»†ç²’åº¦æƒé™æ§åˆ¶     |
| **APIæ»¥ç”¨**  | ğŸŸ¡ ä¸­    | ğŸŸ¢ ä½    | é€Ÿç‡é™åˆ¶ï¼Œç›‘æ§å‘Šè­¦ |

---

## ğŸ“ˆ æˆåŠŸæŒ‡æ ‡

### å®‰å…¨æŒ‡æ ‡

```yaml
å®‰å…¨äº‹ä»¶å‡å°‘:
  - ç™»å½•å¤±è´¥æ”»å‡»: å‡å°‘80%
  - APIæ»¥ç”¨äº‹ä»¶: å‡å°‘90%
  - æƒé™è¿è§„: å‡å°‘95%

æ£€æµ‹èƒ½åŠ›æå‡:
  - å¨èƒæ£€æµ‹æ—¶é—´: <5åˆ†é’Ÿ
  - å“åº”æ—¶é—´: <30åˆ†é’Ÿ
  - è¯¯æŠ¥ç‡: <5%

åˆè§„æ€§è¾¾æˆ:
  - æ•°æ®ä¿æŠ¤åˆè§„: 100%
  - å®‰å…¨ç­–ç•¥æ‰§è¡Œ: 100%
  - å®¡è®¡è¦æ±‚æ»¡è¶³: 100%
```

### ä¸šåŠ¡æŒ‡æ ‡

```yaml
ç”¨æˆ·ä½“éªŒ:
  - ç™»å½•æˆåŠŸç‡: >99.5%
  - ç³»ç»Ÿå¯ç”¨æ€§: >99.9%
  - ç”¨æˆ·æ»¡æ„åº¦: >4.5/5

è¿è¥æ•ˆç‡:
  - å®‰å…¨äº‹ä»¶å¤„ç†æ—¶é—´: å‡å°‘60%
  - äººå·¥å¹²é¢„éœ€æ±‚: å‡å°‘70%
  - è¿ç»´æˆæœ¬: é™ä½20%
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æŠ€æœ¯æ¶æ„ä¼˜åŒ–æŒ‡å—](./01-æŠ€æœ¯æ¶æ„ä¼˜åŒ–æŒ‡å—.md)
- [æ€§èƒ½ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ](./02-æ€§èƒ½ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ.md)
- [ä»£ç è´¨é‡æå‡è®¡åˆ’](./03-ä»£ç è´¨é‡æå‡è®¡åˆ’.md)
- [ç³»ç»Ÿç›‘æ§ä¼˜åŒ–æ–¹æ¡ˆ](./05-ç³»ç»Ÿç›‘æ§ä¼˜åŒ–æ–¹æ¡ˆ.md)

---

**æ–‡æ¡£ç»´æŠ¤**: é¡¹ç›®ç»ç†  
**æŠ€æœ¯å®¡æ ¸**: å®‰å…¨æ¶æ„å¸ˆ  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ22æ—¥

```

```
