# 英语四级智能训练系统安全性增强方案

## 📋 文档信息

**文档版本**: v1.0  
**创建日期**: 2025年1月22日  
**基于报告**: 全面技术架构审查报告 + 深度符合性审查报告  
**优化目标**: 建立全面的系统安全防护体系  
**预期收益**: 安全风险降低90%，合规性提升100%  
**实施周期**: 8-10周

---

## 🔍 安全现状评估

### 当前安全基线

基于审查报告，系统安全现状分析：

| 安全领域     | 当前状态 | 风险等级 | 目标状态   | 改进优先级 |
| ------------ | -------- | -------- | ---------- | ---------- |
| **身份认证** | 基础实现 | 🟡 中等  | 多因子认证 | 🔴 高      |
| **权限控制** | 角色基础 | 🟡 中等  | 细粒度权限 | 🔴 高      |
| **数据加密** | 部分加密 | 🔴 高    | 全面加密   | 🔴 高      |
| **API安全**  | 基础防护 | 🟡 中等  | 全面防护   | 🟡 中      |
| **输入验证** | 不完整   | 🔴 高    | 全面验证   | 🔴 高      |
| **日志审计** | 基础日志 | 🟡 中等  | 完整审计   | 🟡 中      |
| **安全监控** | 缺失     | 🔴 高    | 实时监控   | 🔴 高      |
| **合规性**   | 部分合规 | 🟡 中等  | 全面合规   | 🟡 中      |

### 核心安全风险

1. **🔴 高风险**
   - 敏感数据未加密存储
   - 缺乏完整的输入验证机制
   - 安全监控和告警机制缺失
   - API接口缺乏速率限制

2. **🟡 中风险**
   - 权限控制粒度不够细
   - 日志记录不够完整
   - 第三方依赖安全检查不足
   - 安全配置管理不规范

3. **🟢 低风险**
   - 基础认证机制已实现
   - HTTPS传输已启用
   - 基本的SQL注入防护

---

## 🔐 身份认证和授权增强

### 1. 多因子认证(MFA)实施

#### JWT增强认证

```python
# users/authentication.py
import jwt
import pyotp
from datetime import datetime, timedelta
from django.contrib.auth import get_user_model
from django.core.cache import cache
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from cryptography.fernet import Fernet

User = get_user_model()

class EnhancedJWTAuthentication(BaseAuthentication):
    """增强的JWT认证"""

    def authenticate(self, request):
        """认证用户"""
        auth_header = request.META.get('HTTP_AUTHORIZATION')
        if not auth_header or not auth_header.startswith('Bearer '):
            return None

        token = auth_header.split(' ')[1]

        try:
            # 验证JWT token
            payload = jwt.decode(
                token,
                settings.SECRET_KEY,
                algorithms=['HS256']
            )

            user_id = payload.get('user_id')
            session_id = payload.get('session_id')

            # 检查会话是否有效
            if not self._is_session_valid(user_id, session_id):
                raise AuthenticationFailed('会话已失效')

            # 检查用户状态
            user = User.objects.get(id=user_id, is_active=True)

            # 检查是否需要MFA验证
            if user.mfa_enabled and not self._is_mfa_verified(user_id, session_id):
                raise AuthenticationFailed('需要多因子认证')

            # 更新最后活动时间
            self._update_last_activity(user_id, session_id)

            return (user, token)

        except jwt.ExpiredSignatureError:
            raise AuthenticationFailed('Token已过期')
        except jwt.InvalidTokenError:
            raise AuthenticationFailed('无效的Token')
        except User.DoesNotExist:
            raise AuthenticationFailed('用户不存在')

    def _is_session_valid(self, user_id: int, session_id: str) -> bool:
        """检查会话是否有效"""
        session_key = f'session:{user_id}:{session_id}'
        return cache.get(session_key) is not None

    def _is_mfa_verified(self, user_id: int, session_id: str) -> bool:
        """检查MFA是否已验证"""
        mfa_key = f'mfa_verified:{user_id}:{session_id}'
        return cache.get(mfa_key, False)

    def _update_last_activity(self, user_id: int, session_id: str) -> None:
        """更新最后活动时间"""
        session_key = f'session:{user_id}:{session_id}'
        cache.set(session_key, datetime.now().isoformat(), timeout=3600)

class MFAService:
    """多因子认证服务"""

    def __init__(self):
        self.cipher = Fernet(settings.MFA_ENCRYPTION_KEY)

    def generate_totp_secret(self, user: User) -> str:
        """生成TOTP密钥"""
        secret = pyotp.random_base32()

        # 加密存储密钥
        encrypted_secret = self.cipher.encrypt(secret.encode())
        user.totp_secret = encrypted_secret
        user.save(update_fields=['totp_secret'])

        return secret

    def verify_totp(self, user: User, token: str) -> bool:
        """验证TOTP令牌"""
        if not user.totp_secret:
            return False

        try:
            # 解密密钥
            secret = self.cipher.decrypt(user.totp_secret).decode()
            totp = pyotp.TOTP(secret)

            # 验证令牌（允许30秒时间窗口）
            return totp.verify(token, valid_window=1)

        except Exception:
            return False

    def generate_backup_codes(self, user: User) -> List[str]:
        """生成备用验证码"""
        import secrets

        codes = []
        for _ in range(10):
            code = '-'.join([
                secrets.token_hex(2).upper()
                for _ in range(3)
            ])
            codes.append(code)

        # 加密存储备用码
        encrypted_codes = [
            self.cipher.encrypt(code.encode()).decode()
            for code in codes
        ]

        user.backup_codes = encrypted_codes
        user.save(update_fields=['backup_codes'])

        return codes

    def verify_backup_code(self, user: User, code: str) -> bool:
        """验证备用码"""
        if not user.backup_codes:
            return False

        try:
            # 解密并验证备用码
            for i, encrypted_code in enumerate(user.backup_codes):
                decrypted_code = self.cipher.decrypt(encrypted_code.encode()).decode()
                if decrypted_code == code:
                    # 使用后删除备用码
                    user.backup_codes.pop(i)
                    user.save(update_fields=['backup_codes'])
                    return True

            return False

        except Exception:
            return False
```

#### 细粒度权限控制

```python
# users/permissions.py
from typing import List, Dict, Any
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from rest_framework.permissions import BasePermission
from enum import Enum

class ResourceType(Enum):
    """资源类型枚举"""
    COURSE = 'course'
    LESSON = 'lesson'
    ASSIGNMENT = 'assignment'
    GRADE = 'grade'
    USER = 'user'
    SYSTEM = 'system'

class Action(Enum):
    """操作类型枚举"""
    CREATE = 'create'
    READ = 'read'
    UPDATE = 'update'
    DELETE = 'delete'
    EXECUTE = 'execute'
    MANAGE = 'manage'

class PermissionManager:
    """权限管理器"""

    def __init__(self):
        self.permission_cache = {}

    def check_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action,
        resource_id: str = None,
        context: Dict[str, Any] = None
    ) -> bool:
        """检查用户权限"""

        # 超级管理员拥有所有权限
        if user.is_superuser:
            return True

        # 检查角色权限
        if self._check_role_permission(user, resource_type, action):
            return True

        # 检查资源级权限
        if resource_id and self._check_resource_permission(
            user, resource_type, action, resource_id
        ):
            return True

        # 检查上下文权限
        if context and self._check_context_permission(
            user, resource_type, action, context
        ):
            return True

        return False

    def _check_role_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action
    ) -> bool:
        """检查角色权限"""
        role_permissions = {
            'admin': {
                ResourceType.SYSTEM: [Action.MANAGE],
                ResourceType.USER: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
                ResourceType.COURSE: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
            },
            'teacher': {
                ResourceType.COURSE: [Action.CREATE, Action.READ, Action.UPDATE],
                ResourceType.LESSON: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
                ResourceType.ASSIGNMENT: [Action.CREATE, Action.READ, Action.UPDATE, Action.DELETE],
                ResourceType.GRADE: [Action.CREATE, Action.READ, Action.UPDATE],
            },
            'student': {
                ResourceType.COURSE: [Action.READ],
                ResourceType.LESSON: [Action.READ],
                ResourceType.ASSIGNMENT: [Action.READ, Action.EXECUTE],
                ResourceType.GRADE: [Action.READ],
            }
        }

        user_role_permissions = role_permissions.get(user.role, {})
        allowed_actions = user_role_permissions.get(resource_type, [])

        return action in allowed_actions

    def _check_resource_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action,
        resource_id: str
    ) -> bool:
        """检查资源级权限"""
        # 教师只能操作自己的课程
        if user.role == 'teacher' and resource_type == ResourceType.COURSE:
            from learning.models import Course
            try:
                course = Course.objects.get(id=resource_id)
                return course.teacher == user
            except Course.DoesNotExist:
                return False

        # 学生只能访问已选课程
        if user.role == 'student' and resource_type == ResourceType.COURSE:
            from learning.models import Enrollment
            return Enrollment.objects.filter(
                student=user,
                course_id=resource_id,
                status='active'
            ).exists()

        return False

    def _check_context_permission(
        self,
        user,
        resource_type: ResourceType,
        action: Action,
        context: Dict[str, Any]
    ) -> bool:
        """检查上下文权限"""
        # 时间窗口权限
        if 'time_window' in context:
            from datetime import datetime
            start_time = context['time_window'].get('start')
            end_time = context['time_window'].get('end')
            now = datetime.now()

            if start_time and now < start_time:
                return False
            if end_time and now > end_time:
                return False

        # IP地址限制
        if 'allowed_ips' in context:
            user_ip = context.get('user_ip')
            allowed_ips = context['allowed_ips']
            if user_ip not in allowed_ips:
                return False

        return True

class ResourcePermission(BasePermission):
    """资源权限检查"""

    def __init__(self, resource_type: ResourceType, action: Action):
        self.resource_type = resource_type
        self.action = action
        self.permission_manager = PermissionManager()

    def has_permission(self, request, view):
        """检查权限"""
        if not request.user or not request.user.is_authenticated:
            return False

        # 获取资源ID
        resource_id = view.kwargs.get('pk') or request.data.get('id')

        # 构建上下文
        context = {
            'user_ip': self._get_client_ip(request),
            'user_agent': request.META.get('HTTP_USER_AGENT', ''),
            'timestamp': datetime.now()
        }

        return self.permission_manager.check_permission(
            request.user,
            self.resource_type,
            self.action,
            resource_id,
            context
        )

    def _get_client_ip(self, request):
        """获取客户端IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
```

### 2. 会话管理增强

```python
# users/session_management.py
import uuid
from datetime import datetime, timedelta
from django.core.cache import cache
from django.contrib.auth import get_user_model
from typing import Dict, List, Optional

User = get_user_model()

class SessionManager:
    """会话管理器"""

    def __init__(self):
        self.session_timeout = 3600  # 1小时
        self.max_sessions_per_user = 5

    def create_session(
        self,
        user: User,
        device_info: Dict[str, str],
        ip_address: str
    ) -> str:
        """创建新会话"""
        session_id = str(uuid.uuid4())

        # 检查并清理过期会话
        self._cleanup_expired_sessions(user.id)

        # 检查会话数量限制
        active_sessions = self._get_active_sessions(user.id)
        if len(active_sessions) >= self.max_sessions_per_user:
            # 删除最旧的会话
            oldest_session = min(active_sessions, key=lambda x: x['created_at'])
            self._revoke_session(user.id, oldest_session['session_id'])

        # 创建会话数据
        session_data = {
            'user_id': user.id,
            'session_id': session_id,
            'device_info': device_info,
            'ip_address': ip_address,
            'created_at': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
            'is_active': True
        }

        # 存储会话
        session_key = f'session:{user.id}:{session_id}'
        cache.set(session_key, session_data, timeout=self.session_timeout)

        # 更新用户会话列表
        self._add_to_user_sessions(user.id, session_id)

        return session_id

    def validate_session(
        self,
        user_id: int,
        session_id: str,
        ip_address: str = None
    ) -> bool:
        """验证会话"""
        session_key = f'session:{user_id}:{session_id}'
        session_data = cache.get(session_key)

        if not session_data:
            return False

        # 检查会话是否激活
        if not session_data.get('is_active', False):
            return False

        # 检查IP地址（可选）
        if ip_address and session_data.get('ip_address') != ip_address:
            # 记录可疑活动
            self._log_suspicious_activity(user_id, session_id, ip_address)
            return False

        # 更新最后活动时间
        session_data['last_activity'] = datetime.now().isoformat()
        cache.set(session_key, session_data, timeout=self.session_timeout)

        return True

    def revoke_session(self, user_id: int, session_id: str) -> bool:
        """撤销会话"""
        return self._revoke_session(user_id, session_id)

    def revoke_all_sessions(self, user_id: int, except_session: str = None) -> int:
        """撤销用户所有会话"""
        active_sessions = self._get_active_sessions(user_id)
        revoked_count = 0

        for session in active_sessions:
            session_id = session['session_id']
            if session_id != except_session:
                if self._revoke_session(user_id, session_id):
                    revoked_count += 1

        return revoked_count

    def get_user_sessions(self, user_id: int) -> List[Dict]:
        """获取用户活跃会话"""
        return self._get_active_sessions(user_id)

    def _revoke_session(self, user_id: int, session_id: str) -> bool:
        """内部撤销会话方法"""
        session_key = f'session:{user_id}:{session_id}'
        session_data = cache.get(session_key)

        if session_data:
            session_data['is_active'] = False
            session_data['revoked_at'] = datetime.now().isoformat()
            cache.set(session_key, session_data, timeout=300)  # 保留5分钟用于审计

            # 从用户会话列表中移除
            self._remove_from_user_sessions(user_id, session_id)
            return True

        return False

    def _get_active_sessions(self, user_id: int) -> List[Dict]:
        """获取用户活跃会话"""
        user_sessions_key = f'user_sessions:{user_id}'
        session_ids = cache.get(user_sessions_key, [])

        active_sessions = []
        for session_id in session_ids:
            session_key = f'session:{user_id}:{session_id}'
            session_data = cache.get(session_key)

            if session_data and session_data.get('is_active', False):
                active_sessions.append(session_data)

        return active_sessions

    def _add_to_user_sessions(self, user_id: int, session_id: str) -> None:
        """添加到用户会话列表"""
        user_sessions_key = f'user_sessions:{user_id}'
        session_ids = cache.get(user_sessions_key, [])

        if session_id not in session_ids:
            session_ids.append(session_id)
            cache.set(user_sessions_key, session_ids, timeout=86400)  # 24小时

    def _remove_from_user_sessions(self, user_id: int, session_id: str) -> None:
        """从用户会话列表中移除"""
        user_sessions_key = f'user_sessions:{user_id}'
        session_ids = cache.get(user_sessions_key, [])

        if session_id in session_ids:
            session_ids.remove(session_id)
            cache.set(user_sessions_key, session_ids, timeout=86400)

    def _cleanup_expired_sessions(self, user_id: int) -> None:
        """清理过期会话"""
        active_sessions = self._get_active_sessions(user_id)
        current_time = datetime.now()

        for session in active_sessions:
            last_activity = datetime.fromisoformat(session['last_activity'])
            if current_time - last_activity > timedelta(seconds=self.session_timeout):
                self._revoke_session(user_id, session['session_id'])

    def _log_suspicious_activity(
        self,
        user_id: int,
        session_id: str,
        suspicious_ip: str
    ) -> None:
        """记录可疑活动"""
        from monitoring.models import SecurityEvent

        SecurityEvent.objects.create(
            event_type='suspicious_ip',
            user_id=user_id,
            session_id=session_id,
            details={
                'suspicious_ip': suspicious_ip,
                'timestamp': datetime.now().isoformat()
            },
            severity='medium'
        )
```

---

## 🔒 数据保护和加密

### 1. 敏感数据加密

```python
# utils/encryption.py
import base64
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from django.conf import settings
from typing import Union, Optional

class DataEncryption:
    """数据加密工具类"""

    def __init__(self):
        self.master_key = settings.ENCRYPTION_MASTER_KEY.encode()
        self.salt = settings.ENCRYPTION_SALT.encode()

    def _derive_key(self, context: str = 'default') -> bytes:
        """派生加密密钥"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self.salt + context.encode(),
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        return key

    def encrypt_field(self, data: str, context: str = 'default') -> str:
        """加密字段数据"""
        if not data:
            return data

        key = self._derive_key(context)
        fernet = Fernet(key)

        encrypted_data = fernet.encrypt(data.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()

    def decrypt_field(self, encrypted_data: str, context: str = 'default') -> str:
        """解密字段数据"""
        if not encrypted_data:
            return encrypted_data

        try:
            key = self._derive_key(context)
            fernet = Fernet(key)

            decoded_data = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = fernet.decrypt(decoded_data)
            return decrypted_data.decode()
        except Exception:
            # 解密失败，可能是旧数据或损坏数据
            return encrypted_data

    def hash_password(self, password: str, salt: Optional[str] = None) -> tuple:
        """哈希密码"""
        if salt is None:
            salt = base64.urlsafe_b64encode(hashlib.sha256(
                self.master_key + password.encode()
            ).digest()[:16]).decode()

        # 使用PBKDF2进行密码哈希
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt.encode(),
            iterations=100000,
        )

        hashed = base64.urlsafe_b64encode(
            kdf.derive(password.encode())
        ).decode()

        return hashed, salt

    def verify_password(self, password: str, hashed: str, salt: str) -> bool:
        """验证密码"""
        try:
            new_hashed, _ = self.hash_password(password, salt)
            return new_hashed == hashed
        except Exception:
            return False

# models/encrypted_fields.py
from django.db import models
from utils.encryption import DataEncryption

class EncryptedTextField(models.TextField):
    """加密文本字段"""

    def __init__(self, *args, encryption_context='default', **kwargs):
        self.encryption_context = encryption_context
        self.encryptor = DataEncryption()
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        """从数据库读取时解密"""
        if value is None:
            return value
        return self.encryptor.decrypt_field(value, self.encryption_context)

    def to_python(self, value):
        """转换为Python对象"""
        if isinstance(value, str) or value is None:
            return value
        return str(value)

    def get_prep_value(self, value):
        """保存到数据库前加密"""
        if value is None:
            return value
        return self.encryptor.encrypt_field(str(value), self.encryption_context)

class EncryptedEmailField(models.EmailField):
    """加密邮箱字段"""

    def __init__(self, *args, **kwargs):
        self.encryptor = DataEncryption()
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        if value is None:
            return value
        return self.encryptor.decrypt_field(value, 'email')

    def get_prep_value(self, value):
        if value is None:
            return value
        return self.encryptor.encrypt_field(str(value), 'email')

class EncryptedJSONField(models.JSONField):
    """加密JSON字段"""

    def __init__(self, *args, encryption_context='json', **kwargs):
        self.encryption_context = encryption_context
        self.encryptor = DataEncryption()
        super().__init__(*args, **kwargs)

    def from_db_value(self, value, expression, connection):
        if value is None:
            return value

        # 先解密，再解析JSON
        decrypted = self.encryptor.decrypt_field(value, self.encryption_context)
        return super().to_python(decrypted)

    def get_prep_value(self, value):
        if value is None:
            return value

        # 先序列化JSON，再加密
        json_str = super().get_prep_value(value)
        return self.encryptor.encrypt_field(json_str, self.encryption_context)
```

### 2. 数据库安全配置

```python
# settings/security.py
import os
from pathlib import Path

# 数据库连接安全配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST', 'localhost'),
        'PORT': os.getenv('DB_PORT', '5432'),
        'OPTIONS': {
            'sslmode': 'require',  # 强制SSL连接
            'sslcert': os.getenv('DB_SSL_CERT'),
            'sslkey': os.getenv('DB_SSL_KEY'),
            'sslrootcert': os.getenv('DB_SSL_ROOT_CERT'),
            'connect_timeout': 10,
            'options': '-c default_transaction_isolation=serializable'
        },
        'CONN_MAX_AGE': 600,  # 连接池配置
        'CONN_HEALTH_CHECKS': True,
    }
}

# Redis安全配置
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': f"redis://:{os.getenv('REDIS_PASSWORD')}@{os.getenv('REDIS_HOST', 'localhost')}:6379/1",
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {
                'ssl_cert_reqs': 'required',
                'ssl_ca_certs': os.getenv('REDIS_SSL_CA_CERTS'),
                'ssl_certfile': os.getenv('REDIS_SSL_CERT'),
                'ssl_keyfile': os.getenv('REDIS_SSL_KEY'),
                'health_check_interval': 30,
            },
            'SERIALIZER': 'django_redis.serializers.json.JSONSerializer',
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
        },
        'KEY_PREFIX': 'cet4_training',
        'TIMEOUT': 300,
    }
}

# 加密配置
ENCRYPTION_MASTER_KEY = os.getenv('ENCRYPTION_MASTER_KEY')
ENCRYPTION_SALT = os.getenv('ENCRYPTION_SALT')
MFA_ENCRYPTION_KEY = os.getenv('MFA_ENCRYPTION_KEY')

# 密码策略
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 12,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
    {
        'NAME': 'users.validators.ComplexPasswordValidator',
    },
]

# 会话安全
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'
SESSION_COOKIE_AGE = 3600  # 1小时
SESSION_EXPIRE_AT_BROWSER_CLOSE = True
SESSION_SAVE_EVERY_REQUEST = True

# CSRF保护
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Strict'
CSRF_USE_SESSIONS = True
CSRF_TRUSTED_ORIGINS = [
    'https://cet4-training.example.com',
]

# 安全头部
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_HSTS_SECONDS = 31536000  # 1年
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_REFERRER_POLICY = 'strict-origin-when-cross-origin'

# 文件上传安全
FILE_UPLOAD_MAX_MEMORY_SIZE = 5242880  # 5MB
DATA_UPLOAD_MAX_MEMORY_SIZE = 5242880  # 5MB
FILE_UPLOAD_PERMISSIONS = 0o644
FILE_UPLOAD_DIRECTORY_PERMISSIONS = 0o755

# 允许的文件类型
ALLOWED_UPLOAD_EXTENSIONS = [
    '.pdf', '.doc', '.docx', '.txt', '.md',
    '.jpg', '.jpeg', '.png', '.gif',
    '.mp3', '.wav', '.mp4', '.avi'
]

# 日志配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'security': {
            'format': '{levelname} {asctime} {name} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'security_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/var/log/cet4_training/security.log',
            'maxBytes': 1024*1024*10,  # 10MB
            'backupCount': 10,
            'formatter': 'security',
        },
    },
    'loggers': {
        'security': {
            'handlers': ['security_file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

---

## 🛡️ API安全防护

### 1. 输入验证和清理

```python
# utils/validators.py
import re
import html
from typing import Any, Dict, List, Union
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

class InputValidator:
    """输入验证器"""

    # 危险模式列表
    DANGEROUS_PATTERNS = [
        r'<script[^>]*>.*?</script>',  # XSS脚本
        r'javascript:',  # JavaScript协议
        r'vbscript:',  # VBScript协议
        r'on\w+\s*=',  # 事件处理器
        r'expression\s*\(',  # CSS表达式
        r'@import',  # CSS导入
        r'\bUNION\b.*\bSELECT\b',  # SQL注入
        r'\bDROP\b.*\bTABLE\b',  # SQL删除
        r'\bINSERT\b.*\bINTO\b',  # SQL插入
        r'\bUPDATE\b.*\bSET\b',  # SQL更新
        r'\bDELETE\b.*\bFROM\b',  # SQL删除
        r'\.\./',  # 路径遍历
        r'\\\\',  # UNC路径
    ]

    def __init__(self):
        self.compiled_patterns = [
            re.compile(pattern, re.IGNORECASE | re.DOTALL)
            for pattern in self.DANGEROUS_PATTERNS
        ]

    def validate_string(
        self,
        value: str,
        max_length: int = None,
        allow_html: bool = False,
        field_name: str = 'field'
    ) -> str:
        """验证字符串输入"""
        if not isinstance(value, str):
            raise ValidationError(f'{field_name}必须是字符串类型')

        # 长度检查
        if max_length and len(value) > max_length:
            raise ValidationError(f'{field_name}长度不能超过{max_length}个字符')

        # 危险模式检查
        for pattern in self.compiled_patterns:
            if pattern.search(value):
                raise ValidationError(f'{field_name}包含不安全的内容')

        # HTML清理
        if not allow_html:
            value = html.escape(value)
        else:
            value = self._sanitize_html(value)

        return value.strip()

    def validate_email(self, email: str) -> str:
        """验证邮箱地址"""
        email_pattern = re.compile(
            r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        )

        if not email_pattern.match(email):
            raise ValidationError('邮箱地址格式不正确')

        return email.lower().strip()

    def validate_phone(self, phone: str) -> str:
        """验证手机号码"""
        phone_pattern = re.compile(r'^1[3-9]\d{9}$')

        # 清理非数字字符
        clean_phone = re.sub(r'\D', '', phone)

        if not phone_pattern.match(clean_phone):
            raise ValidationError('手机号码格式不正确')

        return clean_phone

    def validate_username(self, username: str) -> str:
        """验证用户名"""
        username_pattern = re.compile(r'^[a-zA-Z0-9_]{3,20}$')

        if not username_pattern.match(username):
            raise ValidationError('用户名只能包含字母、数字和下划线，长度3-20个字符')

        return username.lower()

    def validate_file_upload(self, file_obj, allowed_extensions: List[str]) -> None:
        """验证文件上传"""
        if not file_obj:
            raise ValidationError('文件不能为空')

        # 检查文件扩展名
        file_name = file_obj.name.lower()
        if not any(file_name.endswith(ext) for ext in allowed_extensions):
            raise ValidationError(f'不支持的文件类型，允许的类型：{", ".join(allowed_extensions)}')

        # 检查文件大小
        max_size = 10 * 1024 * 1024  # 10MB
        if file_obj.size > max_size:
            raise ValidationError('文件大小不能超过10MB')

        # 检查文件内容
        self._validate_file_content(file_obj)

    def _sanitize_html(self, html_content: str) -> str:
        """清理HTML内容"""
        import bleach

        allowed_tags = [
            'p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li',
            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'
        ]

        allowed_attributes = {
            '*': ['class'],
            'a': ['href', 'title'],
            'img': ['src', 'alt', 'width', 'height'],
        }

        return bleach.clean(
            html_content,
            tags=allowed_tags,
            attributes=allowed_attributes,
            strip=True
        )

    def _validate_file_content(self, file_obj) -> None:
        """验证文件内容"""
        # 读取文件头部检查文件类型
        file_obj.seek(0)
        header = file_obj.read(1024)
        file_obj.seek(0)

        # 检查是否包含可执行代码
        dangerous_signatures = [
            b'\x4d\x5a',  # PE文件头
            b'\x7f\x45\x4c\x46',  # ELF文件头
            b'\xca\xfe\xba\xbe',  # Java class文件
            b'\xfe\xed\xfa',  # Mach-O文件
        ]

        for signature in dangerous_signatures:
            if header.startswith(signature):
                raise ValidationError('不允许上传可执行文件')

class APIInputValidator:
    """API输入验证器"""

    def __init__(self):
        self.validator = InputValidator()

    def validate_request_data(self, data: Dict[str, Any], schema: Dict[str, Dict]) -> Dict[str, Any]:
        """验证请求数据"""
        validated_data = {}

        for field_name, field_config in schema.items():
            field_type = field_config.get('type')
            required = field_config.get('required', False)
            max_length = field_config.get('max_length')
            allow_html = field_config.get('allow_html', False)

            value = data.get(field_name)

            # 必填字段检查
            if required and (value is None or value == ''):
                raise ValidationError(f'{field_name}是必填字段')

            if value is None:
                continue

            # 类型验证
            if field_type == 'string':
                validated_data[field_name] = self.validator.validate_string(
                    value, max_length, allow_html, field_name
                )
            elif field_type == 'email':
                validated_data[field_name] = self.validator.validate_email(value)
            elif field_type == 'phone':
                validated_data[field_name] = self.validator.validate_phone(value)
            elif field_type == 'username':
                validated_data[field_name] = self.validator.validate_username(value)
            elif field_type == 'integer':
                try:
                    validated_data[field_name] = int(value)
                except (ValueError, TypeError):
                    raise ValidationError(f'{field_name}必须是整数')
            elif field_type == 'float':
                try:
                    validated_data[field_name] = float(value)
                except (ValueError, TypeError):
                    raise ValidationError(f'{field_name}必须是数字')
            elif field_type == 'boolean':
                validated_data[field_name] = bool(value)
            else:
                validated_data[field_name] = value

        return validated_data
```

### 2. API速率限制

```python
# utils/rate_limiting.py
import time
from typing import Dict, Optional
from django.core.cache import cache
from django.http import HttpResponse
from rest_framework.throttling import BaseThrottle
from rest_framework.exceptions import Throttled

class EnhancedRateLimit(BaseThrottle):
    """增强的速率限制"""

    def __init__(self):
        self.rate_limits = {
            'login': {'requests': 5, 'window': 300},  # 5次/5分钟
            'api_call': {'requests': 100, 'window': 60},  # 100次/分钟
            'file_upload': {'requests': 10, 'window': 3600},  # 10次/小时
            'ai_request': {'requests': 20, 'window': 3600},  # 20次/小时
        }

    def allow_request(self, request, view):
        """检查是否允许请求"""
        # 获取限制类型
        limit_type = getattr(view, 'rate_limit_type', 'api_call')

        # 获取客户端标识
        client_id = self._get_client_id(request)

        # 检查速率限制
        return self._check_rate_limit(client_id, limit_type)

    def wait(self):
        """返回等待时间"""
        return self.next_request_time - time.time()

    def _get_client_id(self, request) -> str:
        """获取客户端标识"""
        # 优先使用用户ID
        if request.user and request.user.is_authenticated:
            return f'user:{request.user.id}'

        # 使用IP地址
        ip = self._get_client_ip(request)
        return f'ip:{ip}'

    def _get_client_ip(self, request) -> str:
        """获取客户端IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip

    def _check_rate_limit(self, client_id: str, limit_type: str) -> bool:
        """检查速率限制"""
        if limit_type not in self.rate_limits:
            return True

        config = self.rate_limits[limit_type]
        max_requests = config['requests']
        window = config['window']

        # 缓存键
        cache_key = f'rate_limit:{limit_type}:{client_id}'

        # 获取当前计数
        current_time = time.time()
        request_data = cache.get(cache_key, {'count': 0, 'window_start': current_time})

        # 检查是否需要重置窗口
        if current_time - request_data['window_start'] >= window:
            request_data = {'count': 0, 'window_start': current_time}

        # 检查是否超过限制
        if request_data['count'] >= max_requests:
            self.next_request_time = request_data['window_start'] + window
            return False

        # 增加计数
        request_data['count'] += 1
        cache.set(cache_key, request_data, timeout=window)

        return True

class AdaptiveRateLimit(BaseThrottle):
    """自适应速率限制"""

    def __init__(self):
        self.base_limits = {
            'trusted_user': {'requests': 200, 'window': 60},
            'normal_user': {'requests': 100, 'window': 60},
            'suspicious_user': {'requests': 20, 'window': 60},
            'blocked_user': {'requests': 0, 'window': 60},
        }

    def allow_request(self, request, view):
        """自适应速率限制检查"""
        client_id = self._get_client_id(request)
        user_tier = self._get_user_tier(request)

        # 检查是否在黑名单中
        if self._is_blacklisted(client_id):
            return False

        # 根据用户等级调整限制
        limit_config = self.base_limits.get(user_tier, self.base_limits['normal_user'])

        return self._check_adaptive_limit(client_id, limit_config, request)

    def _get_user_tier(self, request) -> str:
        """获取用户等级"""
        if not request.user or not request.user.is_authenticated:
            return 'normal_user'

        # 检查用户信誉度
        trust_score = self._calculate_trust_score(request.user)

        if trust_score >= 90:
            return 'trusted_user'
        elif trust_score >= 50:
            return 'normal_user'
        elif trust_score >= 20:
            return 'suspicious_user'
        else:
            return 'blocked_user'

    def _calculate_trust_score(self, user) -> int:
        """计算用户信誉度"""
        score = 50  # 基础分数

        # 账户年龄加分
        account_age_days = (timezone.now() - user.date_joined).days
        score += min(account_age_days // 30, 20)  # 每月+1分，最多20分

        # 活跃度加分
        recent_activity = self._get_recent_activity_score(user)
        score += recent_activity

        # 违规记录扣分
        violation_count = self._get_violation_count(user)
        score -= violation_count * 10

        return max(0, min(100, score))

    def _get_recent_activity_score(self, user) -> int:
        """获取最近活动分数"""
        # 这里可以根据用户最近的活动情况计算分数
        # 例如：登录频率、API调用成功率等
        return 10  # 简化实现

    def _get_violation_count(self, user) -> int:
        """获取违规次数"""
        from monitoring.models import SecurityEvent

        return SecurityEvent.objects.filter(
            user=user,
            event_type__in=['rate_limit_exceeded', 'suspicious_activity'],
            created_at__gte=timezone.now() - timedelta(days=30)
        ).count()

    def _is_blacklisted(self, client_id: str) -> bool:
        """检查是否在黑名单中"""
        blacklist_key = f'blacklist:{client_id}'
        return cache.get(blacklist_key, False)

    def _check_adaptive_limit(
        self,
        client_id: str,
        limit_config: Dict[str, int],
        request
    ) -> bool:
        """检查自适应限制"""
        max_requests = limit_config['requests']
        window = limit_config['window']

        if max_requests == 0:
            return False

        cache_key = f'adaptive_limit:{client_id}'
        current_time = time.time()

        request_data = cache.get(cache_key, {
            'count': 0,
            'window_start': current_time,
            'violations': 0
        })

        # 重置窗口
        if current_time - request_data['window_start'] >= window:
            request_data = {
                'count': 0,
                'window_start': current_time,
                'violations': max(0, request_data['violations'] - 1)  # 违规次数衰减
            }

        # 动态调整限制
        adjusted_limit = max_requests - (request_data['violations'] * 10)

        if request_data['count'] >= adjusted_limit:
            # 记录违规
            request_data['violations'] += 1
            cache.set(cache_key, request_data, timeout=window * 2)

            # 严重违规时加入黑名单
            if request_data['violations'] >= 5:
                blacklist_key = f'blacklist:{client_id}'
                cache.set(blacklist_key, True, timeout=3600)  # 1小时黑名单

            return False

        request_data['count'] += 1
        cache.set(cache_key, request_data, timeout=window)

        return True
```

---

## 🔍 安全监控和审计

### 1. 安全事件监控

```python
# monitoring/security_monitor.py
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from django.contrib.auth import get_user_model
from django.core.cache import cache
from django.db import models
from enum import Enum

User = get_user_model()
security_logger = logging.getLogger('security')

class SecurityEventType(Enum):
    """安全事件类型"""
    LOGIN_SUCCESS = 'login_success'
    LOGIN_FAILURE = 'login_failure'
    LOGOUT = 'logout'
    PASSWORD_CHANGE = 'password_change'
    PERMISSION_DENIED = 'permission_denied'
    RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded'
    SUSPICIOUS_ACTIVITY = 'suspicious_activity'
    DATA_ACCESS = 'data_access'
    DATA_MODIFICATION = 'data_modification'
    FILE_UPLOAD = 'file_upload'
    API_ABUSE = 'api_abuse'
    SECURITY_VIOLATION = 'security_violation'

class SecuritySeverity(Enum):
    """安全事件严重程度"""
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    CRITICAL = 'critical'

class SecurityEvent(models.Model):
    """安全事件模型"""

    event_type = models.CharField(
        max_length=50,
        choices=[(e.value, e.value) for e in SecurityEventType],
        verbose_name='事件类型'
    )
    severity = models.CharField(
        max_length=20,
        choices=[(s.value, s.value) for s in SecuritySeverity],
        default=SecuritySeverity.LOW.value,
        verbose_name='严重程度'
    )
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='相关用户'
    )
    ip_address = models.GenericIPAddressField(
        null=True,
        blank=True,
        verbose_name='IP地址'
    )
    user_agent = models.TextField(
        null=True,
        blank=True,
        verbose_name='用户代理'
    )
    session_id = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        verbose_name='会话ID'
    )
    details = models.JSONField(
        default=dict,
        verbose_name='事件详情'
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name='创建时间'
    )

    class Meta:
        db_table = 'security_events'
        verbose_name = '安全事件'
        verbose_name_plural = '安全事件'
        indexes = [
            models.Index(fields=['event_type', 'created_at']),
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['ip_address', 'created_at']),
            models.Index(fields=['severity', 'created_at']),
        ]

class SecurityMonitor:
    """安全监控器"""

    def __init__(self):
        self.alert_thresholds = {
            SecurityEventType.LOGIN_FAILURE: {'count': 5, 'window': 300},
            SecurityEventType.RATE_LIMIT_EXCEEDED: {'count': 3, 'window': 600},
            SecurityEventType.PERMISSION_DENIED: {'count': 10, 'window': 300},
            SecurityEventType.SUSPICIOUS_ACTIVITY: {'count': 1, 'window': 60},
        }

    def log_event(
        self,
        event_type: SecurityEventType,
        severity: SecuritySeverity = SecuritySeverity.LOW,
        user: User = None,
        ip_address: str = None,
        user_agent: str = None,
        session_id: str = None,
        details: Dict[str, Any] = None
    ) -> SecurityEvent:
        """记录安全事件"""

        event = SecurityEvent.objects.create(
            event_type=event_type.value,
            severity=severity.value,
            user=user,
            ip_address=ip_address,
            user_agent=user_agent,
            session_id=session_id,
            details=details or {}
        )

        # 记录到日志
        security_logger.info(
            f'Security Event: {event_type.value} | '
            f'Severity: {severity.value} | '
            f'User: {user.username if user else "Anonymous"} | '
            f'IP: {ip_address} | '
            f'Details: {json.dumps(details or {})}'
        )

        # 检查是否需要告警
        self._check_alert_conditions(event)

        return event

    def _check_alert_conditions(self, event: SecurityEvent) -> None:
        """检查告警条件"""
        event_type = SecurityEventType(event.event_type)

        if event_type not in self.alert_thresholds:
            return

        threshold = self.alert_thresholds[event_type]
        time_window = timedelta(seconds=threshold['window'])
        since_time = datetime.now() - time_window

        # 统计时间窗口内的事件数量
        recent_events = SecurityEvent.objects.filter(
            event_type=event.event_type,
            created_at__gte=since_time
        )

        # 按用户或IP分组统计
        if event.user:
            recent_events = recent_events.filter(user=event.user)
            identifier = f'user:{event.user.username}'
        elif event.ip_address:
            recent_events = recent_events.filter(ip_address=event.ip_address)
            identifier = f'ip:{event.ip_address}'
        else:
            return

        event_count = recent_events.count()

        if event_count >= threshold['count']:
            self._trigger_alert(event_type, identifier, event_count, threshold)

    def _trigger_alert(
        self,
        event_type: SecurityEventType,
        identifier: str,
        event_count: int,
        threshold: Dict[str, int]
    ) -> None:
        """触发安全告警"""
        alert_key = f'security_alert:{event_type.value}:{identifier}'

        # 防止重复告警
        if cache.get(alert_key):
            return

        # 设置告警冷却时间
        cache.set(alert_key, True, timeout=threshold['window'])

        # 发送告警
        alert_message = (
            f'安全告警: {event_type.value} 事件频繁发生\n'
            f'标识符: {identifier}\n'
            f'事件数量: {event_count}\n'
            f'时间窗口: {threshold["window"]}秒\n'
            f'阈值: {threshold["count"]}次'
        )

        # 这里可以集成邮件、短信、钉钉等告警方式
        self._send_alert(alert_message, event_type)

    def _send_alert(self, message: str, event_type: SecurityEventType) -> None:
        """发送告警消息"""
        # 记录到高优先级日志
        security_logger.critical(f'SECURITY ALERT: {message}')

        # 可以在这里集成具体的告警渠道
        # 例如：邮件、短信、Slack、钉钉等
        pass

class AuditLogger:
    """审计日志记录器"""

    def __init__(self):
        self.audit_logger = logging.getLogger('audit')

    def log_data_access(
        self,
        user: User,
        resource_type: str,
        resource_id: str,
        action: str,
        ip_address: str = None,
        details: Dict[str, Any] = None
    ) -> None:
        """记录数据访问"""
        audit_data = {
            'timestamp': datetime.now().isoformat(),
            'user_id': user.id,
            'username': user.username,
            'resource_type': resource_type,
            'resource_id': resource_id,
            'action': action,
            'ip_address': ip_address,
            'details': details or {}
        }

        self.audit_logger.info(json.dumps(audit_data))

    def log_admin_action(
        self,
        admin_user: User,
        action: str,
        target_user: User = None,
        details: Dict[str, Any] = None
    ) -> None:
        """记录管理员操作"""
        audit_data = {
            'timestamp': datetime.now().isoformat(),
            'admin_user_id': admin_user.id,
            'admin_username': admin_user.username,
            'action': action,
            'target_user_id': target_user.id if target_user else None,
            'target_username': target_user.username if target_user else None,
            'details': details or {}
        }

        self.audit_logger.warning(json.dumps(audit_data))
```

### 2. 漏洞扫描和检测

```python
# security/vulnerability_scanner.py
import re
import subprocess
from typing import List, Dict, Any
from pathlib import Path
from dataclasses import dataclass

@dataclass
class Vulnerability:
    """漏洞信息"""
    severity: str
    category: str
    description: str
    file_path: str
    line_number: int
    recommendation: str

class VulnerabilityScanner:
    """漏洞扫描器"""

    def __init__(self):
        self.security_patterns = {
            'sql_injection': [
                r'\bexecute\s*\(.*%.*\)',
                r'\bcursor\.execute\s*\(.*\+.*\)',
                r'\braw\s*\(.*\+.*\)',
            ],
            'xss': [
                r'\bmark_safe\s*\(',
                r'\|safe\b',
                r'\brender_to_string\s*\(.*\+.*\)',
            ],
            'path_traversal': [
                r'\bopen\s*\(.*\+.*\)',
                r'\bfile\s*\(.*\+.*\)',
                r'\.\./',
            ],
            'hardcoded_secrets': [
                r'password\s*=\s*["\'][^"\'
]{8,}["\']',
                r'secret\s*=\s*["\'][^"\'
]{16,}["\']',
                r'api_key\s*=\s*["\'][^"\'
]{16,}["\']',
            ],
            'weak_crypto': [
                r'\bmd5\s*\(',
                r'\bsha1\s*\(',
                r'\bDES\b',
                r'\bRC4\b',
            ]
        }

    def scan_codebase(self, project_path: Path) -> List[Vulnerability]:
        """扫描代码库"""
        vulnerabilities = []

        # 扫描Python文件
        for py_file in project_path.rglob('*.py'):
            vulnerabilities.extend(self._scan_file(py_file))

        # 扫描模板文件
        for template_file in project_path.rglob('*.html'):
            vulnerabilities.extend(self._scan_template(template_file))

        # 扫描配置文件
        for config_file in project_path.rglob('*.env'):
            vulnerabilities.extend(self._scan_config(config_file))

        return vulnerabilities

    def _scan_file(self, file_path: Path) -> List[Vulnerability]:
        """扫描Python文件"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            for category, patterns in self.security_patterns.items():
                for pattern in patterns:
                    for line_num, line in enumerate(lines, 1):
                        if re.search(pattern, line, re.IGNORECASE):
                            vulnerability = Vulnerability(
                                severity=self._get_severity(category),
                                category=category,
                                description=self._get_description(category),
                                file_path=str(file_path),
                                line_number=line_num,
                                recommendation=self._get_recommendation(category)
                            )
                            vulnerabilities.append(vulnerability)

        except Exception as e:
            print(f"扫描文件 {file_path} 时出错: {e}")

        return vulnerabilities

    def _scan_template(self, file_path: Path) -> List[Vulnerability]:
        """扫描模板文件"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            # 检查XSS漏洞
            xss_patterns = [
                r'\{\{.*\|safe.*\}\}',
                r'\{\%.*autoescape\s+off.*\%\}',
            ]

            for pattern in xss_patterns:
                for line_num, line in enumerate(lines, 1):
                    if re.search(pattern, line):
                        vulnerability = Vulnerability(
                            severity='high',
                            category='xss',
                            description='模板中可能存在XSS漏洞',
                            file_path=str(file_path),
                            line_number=line_num,
                            recommendation='使用Django的自动转义功能，避免使用|safe过滤器'
                        )
                        vulnerabilities.append(vulnerability)

        except Exception as e:
            print(f"扫描模板文件 {file_path} 时出错: {e}")

        return vulnerabilities

    def _scan_config(self, file_path: Path) -> List[Vulnerability]:
        """扫描配置文件"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.split('\n')

            # 检查硬编码密钥
            for line_num, line in enumerate(lines, 1):
                if re.search(r'\w+\s*=\s*["\'][^"\'
]{16,}["\']', line):
                    vulnerability = Vulnerability(
                        severity='critical',
                        category='hardcoded_secrets',
                        description='配置文件中发现硬编码密钥',
                        file_path=str(file_path),
                        line_number=line_num,
                        recommendation='使用环境变量或密钥管理服务存储敏感信息'
                    )
                    vulnerabilities.append(vulnerability)

        except Exception as e:
            print(f"扫描配置文件 {file_path} 时出错: {e}")

        return vulnerabilities

    def _get_severity(self, category: str) -> str:
        """获取漏洞严重程度"""
        severity_map = {
            'sql_injection': 'critical',
            'xss': 'high',
            'path_traversal': 'high',
            'hardcoded_secrets': 'critical',
            'weak_crypto': 'medium'
        }
        return severity_map.get(category, 'low')

    def _get_description(self, category: str) -> str:
        """获取漏洞描述"""
        descriptions = {
            'sql_injection': 'SQL注入漏洞：可能允许攻击者执行恶意SQL语句',
            'xss': '跨站脚本攻击漏洞：可能允许攻击者注入恶意脚本',
            'path_traversal': '路径遍历漏洞：可能允许攻击者访问系统文件',
            'hardcoded_secrets': '硬编码密钥：敏感信息暴露在代码中',
            'weak_crypto': '弱加密算法：使用了不安全的加密方法'
        }
        return descriptions.get(category, '未知漏洞类型')

    def _get_recommendation(self, category: str) -> str:
        """获取修复建议"""
        recommendations = {
            'sql_injection': '使用参数化查询或ORM，避免字符串拼接',
            'xss': '使用Django的自动转义功能，对用户输入进行验证和清理',
            'path_traversal': '验证文件路径，使用安全的文件操作方法',
            'hardcoded_secrets': '使用环境变量或密钥管理服务存储敏感信息',
            'weak_crypto': '使用强加密算法，如AES-256、SHA-256等'
        }
        return recommendations.get(category, '请咨询安全专家')

    def generate_report(self, vulnerabilities: List[Vulnerability]) -> str:
        """生成扫描报告"""
        if not vulnerabilities:
            return "未发现安全漏洞"

        report = "# 安全漏洞扫描报告\n\n"

        # 按严重程度分组
        by_severity = {}
        for vuln in vulnerabilities:
            if vuln.severity not in by_severity:
                by_severity[vuln.severity] = []
            by_severity[vuln.severity].append(vuln)

        # 生成报告
        severity_order = ['critical', 'high', 'medium', 'low']
        for severity in severity_order:
            if severity in by_severity:
                report += f"## {severity.upper()} 级别漏洞 ({len(by_severity[severity])}个)\n\n"

                for vuln in by_severity[severity]:
                    report += f"### {vuln.category}\n"
                    report += f"- **文件**: {vuln.file_path}:{vuln.line_number}\n"
                    report += f"- **描述**: {vuln.description}\n"
                    report += f"- **建议**: {vuln.recommendation}\n\n"

        return report

class DependencyScanner:
    """依赖漏洞扫描器"""

    def scan_dependencies(self, requirements_file: Path) -> List[Dict[str, Any]]:
        """扫描依赖漏洞"""
        vulnerabilities = []

        try:
            # 使用safety工具扫描Python依赖
            result = subprocess.run(
                ['safety', 'check', '-r', str(requirements_file), '--json'],
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                import json
                safety_data = json.loads(result.stdout)

                for vuln in safety_data:
                    vulnerabilities.append({
                        'package': vuln.get('package'),
                        'version': vuln.get('installed_version'),
                        'vulnerability_id': vuln.get('vulnerability_id'),
                        'description': vuln.get('advisory'),
                        'severity': 'high'  # Safety通常报告高危漏洞
                    })

        except Exception as e:
            print(f"依赖扫描失败: {e}")

        return vulnerabilities
```

---

## 📋 合规性检查

### 1. 数据保护合规

```python
# compliance/gdpr_compliance.py
from typing import Dict, List, Any
from django.contrib.auth import get_user_model
from django.db import models
from datetime import datetime, timedelta

User = get_user_model()

class DataProtectionCompliance:
    """数据保护合规检查"""

    def __init__(self):
        self.retention_policies = {
            'user_data': 365 * 7,  # 7年
            'learning_records': 365 * 5,  # 5年
            'log_data': 365 * 2,  # 2年
            'session_data': 30,  # 30天
        }

    def check_data_retention(self) -> Dict[str, Any]:
        """检查数据保留合规性"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # 检查用户数据保留
        old_users = User.objects.filter(
            last_login__lt=datetime.now() - timedelta(days=self.retention_policies['user_data']),
            is_active=False
        )

        if old_users.exists():
            compliance_report['issues'].append({
                'type': 'data_retention',
                'description': f'发现{old_users.count()}个超过保留期限的用户账户',
                'severity': 'medium'
            })
            compliance_report['recommendations'].append(
                '建议清理超过保留期限的用户数据'
            )

        return compliance_report

    def check_consent_management(self) -> Dict[str, Any]:
        """检查用户同意管理"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # 检查是否有用户同意记录
        users_without_consent = User.objects.filter(
            consent_records__isnull=True
        )

        if users_without_consent.exists():
            compliance_report['compliant'] = False
            compliance_report['issues'].append({
                'type': 'missing_consent',
                'description': f'{users_without_consent.count()}个用户缺少同意记录',
                'severity': 'high'
            })

        return compliance_report

    def generate_privacy_report(self, user: User) -> Dict[str, Any]:
        """生成用户隐私报告"""
        report = {
            'user_id': user.id,
            'data_collected': [],
            'processing_purposes': [],
            'data_sharing': [],
            'retention_periods': {}
        }

        # 收集用户数据信息
        report['data_collected'] = [
            '基本信息（姓名、邮箱、手机号）',
            '学习记录和进度',
            '系统使用日志',
            '设备和浏览器信息'
        ]

        report['processing_purposes'] = [
            '提供教育服务',
            '个性化学习推荐',
            '系统安全和维护',
            '服务改进和分析'
        ]

        return report

class SecurityCompliance:
    """安全合规检查"""

    def check_password_policy(self) -> Dict[str, Any]:
        """检查密码策略合规性"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # 检查密码策略配置
        from django.conf import settings

        password_validators = getattr(settings, 'AUTH_PASSWORD_VALIDATORS', [])

        required_validators = [
            'MinimumLengthValidator',
            'CommonPasswordValidator',
            'NumericPasswordValidator'
        ]

        configured_validators = [
            validator['NAME'].split('.')[-1]
            for validator in password_validators
        ]

        for required in required_validators:
            if required not in configured_validators:
                compliance_report['compliant'] = False
                compliance_report['issues'].append({
                    'type': 'missing_password_validator',
                    'description': f'缺少密码验证器: {required}',
                    'severity': 'medium'
                })

        return compliance_report

    def check_encryption_compliance(self) -> Dict[str, Any]:
        """检查加密合规性"""
        compliance_report = {
            'compliant': True,
            'issues': [],
            'recommendations': []
        }

        # 检查HTTPS配置
        from django.conf import settings

        if not getattr(settings, 'SECURE_SSL_REDIRECT', False):
            compliance_report['compliant'] = False
            compliance_report['issues'].append({
                'type': 'missing_https_redirect',
                'description': '未启用HTTPS重定向',
                'severity': 'high'
            })

        # 检查会话安全
        if not getattr(settings, 'SESSION_COOKIE_SECURE', False):
            compliance_report['compliant'] = False
            compliance_report['issues'].append({
                'type': 'insecure_session_cookie',
                'description': '会话Cookie未设置Secure标志',
                'severity': 'medium'
            })

        return compliance_report
```

---

## 📅 实施计划

### 阶段一：基础安全加固 (2周)

**目标**: 修复高危安全漏洞，建立基础防护

| 任务         | 负责人     | 工期 | 验收标准                 |
| ------------ | ---------- | ---- | ------------------------ |
| 身份认证增强 | 后端开发   | 3天  | MFA功能可用，JWT安全配置 |
| 输入验证完善 | 后端开发   | 2天  | 所有API接口输入验证      |
| 数据加密实施 | 后端开发   | 4天  | 敏感字段加密存储         |
| HTTPS配置    | 运维工程师 | 1天  | 全站HTTPS，安全头部配置  |
| 密码策略更新 | 后端开发   | 1天  | 强密码策略生效           |

### 阶段二：访问控制优化 (2周)

**目标**: 实现细粒度权限控制和会话管理

| 任务         | 负责人   | 工期 | 验收标准             |
| ------------ | -------- | ---- | -------------------- |
| 权限系统重构 | 后端开发 | 5天  | 细粒度权限控制       |
| 会话管理增强 | 后端开发 | 3天  | 多会话管理，异常检测 |
| API速率限制  | 后端开发 | 2天  | 自适应速率限制       |
| 安全中间件   | 后端开发 | 2天  | 安全检查中间件       |

### 阶段三：监控和审计 (2周)

**目标**: 建立完整的安全监控和审计体系

| 任务           | 负责人     | 工期 | 验收标准       |
| -------------- | ---------- | ---- | -------------- |
| 安全事件监控   | 后端开发   | 4天  | 实时安全监控   |
| 审计日志系统   | 后端开发   | 3天  | 完整审计日志   |
| 告警系统集成   | 运维工程师 | 2天  | 多渠道安全告警 |
| 漏洞扫描自动化 | DevOps     | 3天  | 自动化安全扫描 |

### 阶段四：合规性和测试 (2周)

**目标**: 确保合规性要求，完成安全测试

| 任务       | 负责人   | 工期 | 验收标准         |
| ---------- | -------- | ---- | ---------------- |
| 合规性检查 | 安全专家 | 3天  | 通过合规性审计   |
| 渗透测试   | 安全专家 | 4天  | 无高危漏洞       |
| 安全培训   | 项目经理 | 2天  | 团队安全意识提升 |
| 文档完善   | 技术写作 | 3天  | 完整安全文档     |

---

## ✅ 验收标准

### 功能验收

- [ ] **身份认证**: MFA功能正常，JWT安全配置
- [ ] **权限控制**: 细粒度权限控制，角色权限分离
- [ ] **数据保护**: 敏感数据加密，安全传输
- [ ] **输入验证**: 所有输入点验证，XSS/SQL注入防护
- [ ] **会话管理**: 安全会话管理，异常检测
- [ ] **API安全**: 速率限制，安全头部配置
- [ ] **监控审计**: 实时安全监控，完整审计日志

### 性能验收

- [ ] **响应时间**: 安全检查不影响API响应时间(<100ms)
- [ ] **吞吐量**: 系统吞吐量不降低超过5%
- [ ] **资源消耗**: 安全功能资源消耗<10%

### 安全验收

- [ ] **漏洞扫描**: 无高危和严重漏洞
- [ ] **渗透测试**: 通过第三方安全测试
- [ ] **合规检查**: 满足数据保护法规要求
- [ ] **安全评估**: 安全风险等级降至可接受范围

---

## 📊 风险评估

### 实施风险

| 风险项           | 概率 | 影响 | 风险等级 | 应对措施             |
| ---------------- | ---- | ---- | -------- | -------------------- |
| **性能影响**     | 中   | 中   | 🟡 中    | 性能测试，优化配置   |
| **兼容性问题**   | 低   | 高   | 🟡 中    | 充分测试，渐进式部署 |
| **用户体验影响** | 中   | 中   | 🟡 中    | 用户培训，界面优化   |
| **实施延期**     | 中   | 中   | 🟡 中    | 合理排期，资源保障   |

### 安全风险

| 风险项       | 当前等级 | 目标等级 | 改进措施           |
| ------------ | -------- | -------- | ------------------ |
| **数据泄露** | 🔴 高    | 🟢 低    | 数据加密，访问控制 |
| **身份冒用** | 🟡 中    | 🟢 低    | MFA，会话管理      |
| **权限提升** | 🟡 中    | 🟢 低    | 细粒度权限控制     |
| **API滥用**  | 🟡 中    | 🟢 低    | 速率限制，监控告警 |

---

## 📈 成功指标

### 安全指标

```yaml
安全事件减少:
  - 登录失败攻击: 减少80%
  - API滥用事件: 减少90%
  - 权限违规: 减少95%

检测能力提升:
  - 威胁检测时间: <5分钟
  - 响应时间: <30分钟
  - 误报率: <5%

合规性达成:
  - 数据保护合规: 100%
  - 安全策略执行: 100%
  - 审计要求满足: 100%
```

### 业务指标

```yaml
用户体验:
  - 登录成功率: >99.5%
  - 系统可用性: >99.9%
  - 用户满意度: >4.5/5

运营效率:
  - 安全事件处理时间: 减少60%
  - 人工干预需求: 减少70%
  - 运维成本: 降低20%
```

---

## 📚 相关文档

- [技术架构优化指南](./01-技术架构优化指南.md)
- [性能优化实施方案](./02-性能优化实施方案.md)
- [代码质量提升计划](./03-代码质量提升计划.md)
- [系统监控优化方案](./05-系统监控优化方案.md)

---

**文档维护**: 项目经理  
**技术审核**: 安全架构师  
**最后更新**: 2025年1月22日

```

```
